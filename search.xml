<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>VAE</title>
      <link href="/2024/03/15/VAE/"/>
      <url>/2024/03/15/VAE/</url>
      
        <content type="html"><![CDATA[<h1 id="VAE（变分自动编码器）"><a href="#VAE（变分自动编码器）" class="headerlink" title="VAE（变分自动编码器）"></a><a href="https://arxiv.org/pdf/1606.05908.pdf">VAE（变分自动编码器）</a></h1><ul><li>VAE 是一种包含隐变量的生成模型，主要思想是通过训练一个编码器网络将输入数据映射到潜在空间中，并通过一个解码器网络将潜在空间中的点映射回原始数据空间。这个过程中，VAE 不仅学习如何重构输入数据，还学习如何在潜在空间中进行采样，从而生成新的数据点。</li><li>对变分的理解：用简单的分布函数q去近似复杂的分布函数p。</li><li>AE和VAE的区别<br><img src="https://cdn.jsdelivr.net/gh/HuangLM03/BlogImg@main/20240315140420.png"></li></ul><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>VAE 的提出动机主要是为了解决传统自动编码器（AE）的限制，特别是在数据生成和潜在表示学习方面的限制。传统自动编码器通过学习将输入数据压缩成低维编码，然后再将编码还原为原始数据，但它们在潜在空间的编码是任意的，没有明确的结构或意义。</li><li>学习具有连续和有意义的潜在表示，以便更好地理解数据的结构和分布。</li><li>生成新的数据样本。传统自动编码器在生成新样本时存在困难，因为它们的潜在空间没有明确的分布。</li></ul><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><ul><li>VAE 的输入通常是原始数据，比如图像、文本、音频等。这些原始数据通过编码器网络进行处理，将其映射到潜在空间中</li></ul><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><ul><li>重构的输入数据：解码器网络将从潜在空间中采样得到的点映射回原始数据空间，生成与输入数据尽可能接近的重构数据。</li><li>潜在变量的分布参数：VAE 通过编码器网络学习得到输入数据的潜在变量的概率分布的参数，通常是均值和方差。</li></ul><h2 id="关键步骤"><a href="#关键步骤" class="headerlink" title="关键步骤"></a>关键步骤</h2><p>1.构建模型架构：编码器网络通常接收原始数据作为输入，并输出潜在空间中的均值和方差参数。解码器网络接收来自编码器网络的潜在变量的样本作为输入，并输出重构的输入数据。</p><p>2.定义损失函数：</p><ul><li>重构损失：度量重构数据与原始数据之间的差异，通常使用像素级别的损失函数（如均方误差）。</li><li>KL 散度损失：度量编码器输出的潜在分布与预定义的先验分布之间的差异，通常使用 KL 散度来衡量两个分布之间的差异。</li></ul><p>3.训练模型：使用原始数据集训练模型，通过最小化重构损失和 KL 散度损失来优化模型参数。通过反向传播算法和梯度下降等优化算法来更新模型参数，使得重构数据尽可能接近原始数据，并且学习到的潜在分布与先验分布尽可能接近。</p><p>4.生成数据：在训练完成后，可以通过从学习到的潜在分布中采样得到新的数据样本。<br>可以通过解码器网络将从潜在空间中采样得到的点映射回原始数据空间，生成具有相似分布的新数据样本。</p><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a><a href="https://blog.csdn.net/smileyan9/article/details/107362252">算法原理</a></h2>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> VAE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deep_SVDD</title>
      <link href="/2024/03/14/Deep-SVDD/"/>
      <url>/2024/03/14/Deep-SVDD/</url>
      
        <content type="html"><![CDATA[<h1 id="Deep-SVDD"><a href="#Deep-SVDD" class="headerlink" title="Deep SVDD"></a><a href="https://proceedings.mlr.press/v80/ruff18a/ruff18a.pdf">Deep SVDD</a></h1><ul><li>Deep SVDD是一种基于支持向量机的异常检测方法，它使用深度学习技术来进行数据描述和异常检测。</li><li>Deep SVDD 试图找到一个球形或超球形的最小包围球，将正常数据样本尽可能地包含在球内，而将异常样本排除在球外。</li></ul><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>传统的基于统计方法的异常检测通常假设数据服从特定的分布，如高斯分布，但实际数据往往不满足这种假设。因此，基于深度学习的方法成为了解决这一问题的一种新途径。深度学习模型具有强大的表示学习能力，能够自动地学习到数据的复杂特征和分布，因此被引入到异常检测领域以应对传统方法的局限性。</li><li>Deep SVDD 的提出动机主要是为了克服传统异常检测方法的局限性，提高异常检测的性能和适用范围。</li></ul><h2 id="关键步骤"><a href="#关键步骤" class="headerlink" title="关键步骤"></a>关键步骤</h2><p>1.选择一个合适的神经网络架构，如卷积神经网络（CNN）、全连接神经网络（FCN）。</p><p>2.将原始数据输入到选定的神经网络中，通过反向传播和损失函数训练（通常是球形支持向量机损失函数）。</p><p>3.优化问题。</p><p>4.模型评估。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><ul><li>原始数据通常被表示为向量。视频异常检测中，每个像素点都被看作是一个特征，因此原始数据一般是高维数据。</li></ul><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><ul><li>超球体的参数</li></ul><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p><img src="https://cdn.jsdelivr.net/gh/HuangLM03/BlogImg@main/20240315115609.png"></p><ul><li>第一项是超球体的半径，我们希望将其最小化，从而更准确区分正常样本和异常样本，半径就是区分的阈值。</li><li>第二项是惩罚项。当样本点落于超球体外时，公式的值会变大，只有落于超球体内时，公式的值才会不变，所以神经网络在优化的时候会尽可能地将样本围在超球体内。但是输入数据中会存在异常样本，因此用参数v来控制不让所有样本点都落入超球体内。</li><li><img src="https://cdn.jsdelivr.net/gh/HuangLM03/BlogImg@main/20240315120415.png"></li><li>第三项表示网络权重正则化，用于防止过拟合。</li></ul><p>但输入数据中大多数都是正常样本，因此公式可以简化为如下：</p><ul><li><img src="https://cdn.jsdelivr.net/gh/HuangLM03/BlogImg@main/20240315120652.png"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> Deep SVDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC-SVM</title>
      <link href="/2024/03/14/OC-SVM/"/>
      <url>/2024/03/14/OC-SVM/</url>
      
        <content type="html"><![CDATA[<h1 id="OC-SVM"><a href="#OC-SVM" class="headerlink" title="OC-SVM"></a><a href="https://cs.gmu.edu/~carlotta/teaching/CS-688-f10/readings/oneSVM.pdf">OC-SVM</a></h1><ul><li>一类支持向量机，是支持向量机的变体，常用于异常检测。</li></ul><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><ul><li>解决传统监督学习方法在异常检测问题上的局限性。</li><li>传统的监督学习方法需要大量标记好的数据，即正常样本和异常样本都需要有明确的标签。然而，在异常检测中，异常样本很难获得，甚至是未知的。如果使用SVM训练，就会导致模型对异常样本检测错判率较高。</li><li>OC-SVM只需要正常样本的标签，其基本思想是通过学习正常样本的特征来构建一个超平面，将正常样本和异常样本分离开来。</li></ul><h2 id="算法关键步骤"><a href="#算法关键步骤" class="headerlink" title="算法关键步骤"></a>算法关键步骤</h2><p>1.选择适当的核函数以及相关的参数（核函数的参数、软边界、惩罚参数）。原文中主要提到了线性核还有高斯核，后者的正确率相对而言更高。</p><p><img src="https://cdn.jsdelivr.net/gh/HuangLM03/BlogImg@main/20240314192859.png" alt="高斯核"><br><img src="https://cdn.jsdelivr.net/gh/HuangLM03/BlogImg@main/20240314192937.png"><br>2.优化目标函数</p><ul><li>该函数旨在找到一个超平面，将正常样本和异常样本分离开来。</li></ul><p>3.求解超平面</p><ul><li>确定超平面的参数（法向量、偏置量）和惩罚参数</li><li>可以使用优化算法如梯度下降等来求解支持向量机的对偶问题或原始问题。</li></ul><p>4.模型评估</p><ul><li>交叉验证or验证集</li><li>评估指标：误判率、准确率等</li></ul><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><ul><li>通常只包含正常样本，样本被表示为向量</li><li>核函数和参数</li></ul><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><ul><li>超平面的参数</li></ul><h2 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a><a href="https://blog.csdn.net/comli_cn/article/details/102809384?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171041646316800188562425%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171041646316800188562425&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-102809384-null-null.142%5Ev99%5Epc_search_result_base1&utm_term=%E4%B8%80%E7%B1%BB%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA&spm=1018.2226.3001.4187">数学原理</a></h2><p><img src="https://cdn.jsdelivr.net/gh/HuangLM03/BlogImg@main/20240314205731.png"><br><img src="https://cdn.jsdelivr.net/gh/HuangLM03/BlogImg@main/20240314205805.png"><br><img src="https://cdn.jsdelivr.net/gh/HuangLM03/BlogImg@main/20240314210223.png"><br><img src="https://cdn.jsdelivr.net/gh/HuangLM03/BlogImg@main/20240314210243.png"></p><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成正常样本</span></span><br><span class="line">normal_samples = np.random.randn(<span class="number">100</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成异常样本</span></span><br><span class="line">outliers = np.random.uniform(low=-<span class="number">4</span>, high=<span class="number">4</span>, size=(<span class="number">20</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并正常样本和异常样本</span></span><br><span class="line">X = np.vstack((normal_samples, outliers))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练One-Class SVM模型</span></span><br><span class="line">clf = svm.OneClassSVM(nu=<span class="number">0.05</span>, kernel=<span class="string">&quot;rbf&quot;</span>, gamma=<span class="number">0.1</span>)</span><br><span class="line">clf.fit(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测样本是否为异常</span></span><br><span class="line">y_pred = clf.predict(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化结果</span></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y_pred, cmap=<span class="string">&#x27;viridis&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;One-Class SVM for Outlier Detection&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> OC-SVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>职业生涯规划书</title>
      <link href="/2023/11/05/%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E8%A7%84%E5%88%92%E4%B9%A6/"/>
      <url>/2023/11/05/%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E8%A7%84%E5%88%92%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="职业生涯规划书"><a href="#职业生涯规划书" class="headerlink" title="职业生涯规划书"></a>职业生涯规划书</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li>职业目标<br>1.1 职业目标起源<br>1.2 职业世界探索<br>1.3 适配性分析</li><li>成长行动<br>2.1 目标职业的能力要求<br>2.2 提升能力的成长实践</li><li>成长计划<br>3.1 未来成长的行动计划<br>3.2 计划的评估调整</li></ol><h2 id="1-职业目标"><a href="#1-职业目标" class="headerlink" title="1. 职业目标"></a>1. 职业目标</h2><h3 id="1-1-职业目标起源"><a href="#1-1-职业目标起源" class="headerlink" title="1.1 职业目标起源"></a>1.1 职业目标起源</h3><p>作为一名中国大学生，专业为软件工程，职业生涯规划是迈向成功的第一步。了解自己的职业目标是关键，这需要从内心深处找到动力。我的职业目标起源于：</p><ul><li><strong>兴趣和激情</strong>：我对软件工程充满热情，喜欢解决问题和创建有价值的应用程序。</li><li><strong>家庭背景</strong>：我的家庭成员在科技领域工作，这启发了我对计算机科学的兴趣。</li><li><strong>社会需求</strong>：软件工程领域正在迅速发展，社会对技术专业人才的需求持续增加。</li></ul><h3 id="1-2-职业世界探索"><a href="#1-2-职业世界探索" class="headerlink" title="1.2 职业世界探索"></a>1.2 职业世界探索</h3><p>在确定职业目标之前，我积极探索职业世界，包括：</p><ul><li><strong>实习和实践</strong>：通过实习，我获得了宝贵的实际经验，了解了行业内的工作流程和需求。</li><li><strong>导师和行业专家</strong>：寻找了导师和行业专家的指导，他们分享了关于软件工程领域的见解。</li><li><strong>行业研究</strong>：深入研究软件工程领域的趋势，了解哪些领域具有潜力。</li></ul><h3 id="1-3-适配性分析"><a href="#1-3-适配性分析" class="headerlink" title="1.3 适配性分析"></a>1.3 适配性分析</h3><p>通过自我分析，我了解到自己的优势和劣势，这有助于更好地适应所选的职业道路。适配性分析的一些关键点包括：</p><ul><li><strong>技能与能力</strong>：我拥有编程、算法设计和问题解决的技能，这使我适合从事软件工程。</li><li><strong>兴趣与价值观</strong>：我的兴趣与软件工程领域相契合，我重视创新、贡献和协作。</li><li><strong>挑战与改进</strong>：我意识到需要不断学习和发展，以跟上技术发展的速度。</li></ul><h2 id="2-成长行动"><a href="#2-成长行动" class="headerlink" title="2. 成长行动"></a>2. 成长行动</h2><h3 id="2-1-目标职业的能力要求"><a href="#2-1-目标职业的能力要求" class="headerlink" title="2.1 目标职业的能力要求"></a>2.1 目标职业的能力要求</h3><p>为了实现职业目标，我需要不断提升自己的技能和能力。根据所选择的软件工程职业道路，我需要具备以下能力：</p><ul><li><strong>编程技能</strong>：深入了解多种编程语言和开发工具，能够高效编写代码。</li><li><strong>算法和数据结构</strong>：掌握算法设计和数据结构，以解决复杂的问题。</li><li><strong>团队合作</strong>：良好的团队协作和沟通能力，能够与不同领域的专业人员合作。</li><li><strong>持续学习</strong>：保持学习的动力，随着技术的发展不断提高自己的知识和技能。</li><li><strong>创新思维</strong>：能够提出新的解决方案和创新的想法。</li><li><strong>项目管理</strong>：掌握项目管理技能，包括时间管理和资源规划。</li></ul><h3 id="2-2-提升能力的成长实践"><a href="#2-2-提升能力的成长实践" class="headerlink" title="2.2 提升能力的成长实践"></a>2.2 提升能力的成长实践</h3><p>为了提升这些关键能力，我计划采取以下成长实践：</p><ul><li><strong>学术课程</strong>：继续学习软件工程领域的相关课程，提高技术知识。</li><li><strong>个人项目</strong>：参与个人项目，应用所学知识，提高编程技能。</li><li><strong>实习和兼职</strong>：寻找实际工作机会，积累实际经验。</li><li><strong>参与开源项目</strong>：参与开源社区，与其他开发人员合作，学习最佳实践。</li><li><strong>读书和研究</strong>：不断阅读相关领域的书籍和研究，跟踪行业发展。</li><li><strong>网络和社交</strong>：积极参与技术社区和行业活动，建立专业关系。</li></ul><h2 id="3-成长计划"><a href="#3-成长计划" class="headerlink" title="3. 成长计划"></a>3. 成长计划</h2><h3 id="3-1-未来成长的行动计划"><a href="#3-1-未来成长的行动计划" class="headerlink" title="3.1 未来成长的行动计划"></a>3.1 未来成长的行动计划</h3><p>在未来的职业生涯中，我制定了以下行动计划，以不断提升自己，并实现职业目标：</p><ul><li><strong>学术发展</strong>：完成本科学位，考虑攻读硕士学位，继续深造。</li><li><strong>技能提升</strong>：持续学习新的编程语言和技术，获得相关认证。</li><li><strong>实践经验</strong>：寻找实习机会，积累项目经验，参与开源项目。</li><li><strong>社交网络</strong>：积极参与技术会议、研讨会和社交媒体平台，建立广泛的专业网络。与导师、同学、同事和行业专家建立联系，并参与开源社区。</li></ul><h3 id="3-2-计划的评估调整"><a href="#3-2-计划的评估调整" class="headerlink" title="3.2 计划的评估调整"></a>3.2 计划的评估调整</h3><p>职业生涯规划需要不断的评估和调整，以适应不断变化的环境和目标。我将采取以下措施来确保计划的有效性：</p><ul><li><strong>定期自我评估</strong>：每年回顾自己的职业目标和进展，识别需要改进的领域。</li><li><strong>与导师和顾问交流</strong>：与职业顾问或导师保持联系，获取指导和建议。</li><li><strong>参与继续教育</strong>：根据行业趋势和需求，随时更新自己的技能和知识。</li><li><strong>灵活性</strong>：在计划中保持灵活性，能够适应新机会和挑战。</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这份职业生涯规划书是我的职业旅程的指南。通过明确我的职业目标、成长行动和成长计划，我将能够更有信心地前进，并不断提高自己，以实现我的梦想成为一名卓越的软件工程师。我将不断努力，适应变化，实现我的职业梦想。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>KV数据库-文本读写以及get、del、ins等函数实现</title>
      <link href="/2023/10/08/KV%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%96%87%E6%9C%AC%E8%AF%BB%E5%86%99%E4%BB%A5%E5%8F%8Aget%E3%80%81del%E3%80%81ins%E7%AD%89%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/10/08/KV%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%96%87%E6%9C%AC%E8%AF%BB%E5%86%99%E4%BB%A5%E5%8F%8Aget%E3%80%81del%E3%80%81ins%E7%AD%89%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>WSL+VScode+Ubuntu20.04+gcc9.4.0</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="MyKVDataBase-h"><a href="#MyKVDataBase-h" class="headerlink" title="MyKVDataBase.h"></a>MyKVDataBase.h</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyLogger.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Value LL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> State bool</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">KeyValue</span> &#123;</span><br><span class="line">    <span class="type">char</span>* key;</span><br><span class="line">    Value value;</span><br><span class="line">    State state;</span><br><span class="line">&#125;;        </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="type">int</span> key_len;</span><br><span class="line">    <span class="type">int</span> value_len;</span><br><span class="line">    <span class="type">char</span>* key;</span><br><span class="line">    <span class="type">char</span>* value;</span><br><span class="line">    State state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RAII</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;T*&gt; obj;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RAII</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">RAII</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; obj.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">delete</span> []obj[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T* <span class="title">reqMem</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T* tmp = <span class="keyword">new</span> T[len];</span><br><span class="line">        <span class="keyword">this</span>-&gt;obj.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KVDataBase</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">KVDataBase</span>(<span class="type">const</span> std::string&amp; file_name, <span class="type">const</span> std::string KVDB_logger_name = <span class="string">&quot;./logger.txt&quot;</span>, <span class="type">int</span> MAX_NUM = <span class="number">1e5</span> + <span class="number">7</span>);</span><br><span class="line">    ~<span class="built_in">KVDataBase</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">char</span>* key, <span class="type">char</span>* value, State state = <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">char</span>* key)</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">get</span><span class="params">(<span class="type">char</span>* key)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">purge</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string file_name;</span><br><span class="line">    std::string KVDB_logger_name;    </span><br><span class="line">    <span class="type">int</span> fp, MAX_NUM;</span><br><span class="line">    RAII&lt;<span class="type">char</span>&gt;* all_raii;</span><br><span class="line">    std::map&lt;LL, std::list&lt;KeyValue&gt;&gt; hash_map;</span><br><span class="line">    <span class="type">int</span> inv_num;</span><br><span class="line">    Logger logger;</span><br><span class="line"></span><br><span class="line">    <span class="function">LL <span class="title">get_hash_value</span><span class="params">(<span class="type">char</span>* key)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadFile</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">saveFile</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateHashMap</span><span class="params">(<span class="type">const</span> Message&amp; mes, LL value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">KVDBRead</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; fp, Message&amp; mes, RAII&lt;<span class="type">char</span>&gt;&amp; raii)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">KVDBWrite</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; fp, Message&amp; mes)</span></span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="MyKVDataBase-h-1"><a href="#MyKVDataBase-h-1" class="headerlink" title="MyKVDataBase.h"></a>MyKVDataBase.h</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyKVDataBase.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">KVDataBase::<span class="built_in">KVDataBase</span>(<span class="type">const</span> std::string&amp; file_name, <span class="type">const</span> std::string KVDB_logger_name, <span class="type">int</span> MAX_NUM): <span class="built_in">file_name</span>(file_name), <span class="built_in">MAX_NUM</span>(MAX_NUM), <span class="built_in">inv_num</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;logger = <span class="built_in">Logger</span>(KVDB_logger_name);</span><br><span class="line">    fp = <span class="built_in">open</span>(file_name.<span class="built_in">c_str</span>(), O_RDWR | O_CREAT, <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="number">-1</span>) &#123;</span><br><span class="line">        logger.<span class="built_in">getError</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;        </span><br><span class="line"></span><br><span class="line">    <span class="built_in">loadFile</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">KVDataBase::~<span class="built_in">KVDataBase</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">saveFile</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KVDataBase::set</span><span class="params">(<span class="type">char</span>* key, <span class="type">char</span>* value, State state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> flags = <span class="built_in">fcntl</span>(fp, F_GETFL);</span><br><span class="line">    <span class="built_in">fcntl</span>(fp, F_SETFL, flags | O_APPEND);</span><br><span class="line"></span><br><span class="line">    RAII&lt;<span class="type">char</span>&gt; raii;</span><br><span class="line">    Message mes;</span><br><span class="line">    mes.key_len = <span class="built_in">strlen</span>(key) + <span class="number">1</span>;</span><br><span class="line">    mes.value_len = <span class="built_in">strlen</span>(value) + <span class="number">1</span>;</span><br><span class="line">    mes.key = raii.<span class="built_in">reqMem</span>(mes.key_len);</span><br><span class="line">    mes.value = raii.<span class="built_in">reqMem</span>(mes.value_len);</span><br><span class="line">    <span class="built_in">strcpy</span>(mes.key, key);</span><br><span class="line">    <span class="built_in">strcpy</span>(mes.value, value);</span><br><span class="line">    mes.state = state;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dx = <span class="built_in">sizeof</span>(mes.key_len) + <span class="built_in">sizeof</span>(mes.value_len) +</span><br><span class="line">            mes.key_len + mes.value_len + <span class="built_in">sizeof</span>(mes.state);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">KVDBWrite</span>(fp, mes);</span><br><span class="line"></span><br><span class="line">    Value val = <span class="built_in">lseek</span>(fp, -dx, SEEK_CUR);</span><br><span class="line">    <span class="built_in">lseek</span>(fp, dx, SEEK_CUR);</span><br><span class="line">    <span class="built_in">updateHashMap</span>(mes, val);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fcntl</span>(fp, F_SETFL, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KVDataBase::del</span><span class="params">(<span class="type">char</span>* key)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    LL hash_key = <span class="built_in">get_hash_value</span>(key) % MAX_NUM;</span><br><span class="line">    Message mes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; kv : hash_map[hash_key]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(kv.key, key)) &#123;</span><br><span class="line">            <span class="built_in">lseek</span>(fp, kv.value, SEEK_SET);</span><br><span class="line"></span><br><span class="line">            RAII&lt;<span class="type">char</span>&gt; raii;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">KVDBRead</span>(fp, mes, raii);</span><br><span class="line">            mes.state = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">set</span>(mes.key, mes.value, mes.state);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">KVDataBase::get</span><span class="params">(<span class="type">char</span>* key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL hash_key = <span class="built_in">get_hash_value</span>(key) % MAX_NUM;</span><br><span class="line">    Message mes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; kv : hash_map[hash_key]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(kv.key, key)) &#123;</span><br><span class="line">            <span class="built_in">lseek</span>(fp, kv.value, SEEK_SET);</span><br><span class="line"></span><br><span class="line">            RAII&lt;<span class="type">char</span>&gt; raii;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">KVDBRead</span>(fp, mes, raii);</span><br><span class="line">            <span class="keyword">if</span> (mes.state) &#123;</span><br><span class="line">                <span class="keyword">return</span> std::<span class="built_in">move</span>((std::string)mes.value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">KVDataBase::get_hash_value</span><span class="params">(<span class="type">char</span>* key)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(key); i++) &#123;</span><br><span class="line">        hash = ((hash * <span class="number">256</span>) % MAX_NUM + key[i]) % MAX_NUM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KVDataBase::loadFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    all_raii = <span class="keyword">new</span> <span class="built_in">RAII</span>&lt;<span class="type">char</span>&gt;();</span><br><span class="line">    <span class="built_in">lseek</span>(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    Message mes;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        RAII&lt;<span class="type">char</span>&gt; raii;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">KVDBRead</span>(fp, mes, raii) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dx = <span class="built_in">sizeof</span>(mes.key_len) + <span class="built_in">sizeof</span>(mes.value_len) +</span><br><span class="line">                mes.key_len + mes.value_len + <span class="built_in">sizeof</span>(mes.state);</span><br><span class="line"></span><br><span class="line">        Value value = <span class="built_in">lseek</span>(fp, -dx, SEEK_CUR);</span><br><span class="line">        <span class="built_in">lseek</span>(fp, dx, SEEK_CUR);</span><br><span class="line">        <span class="built_in">updateHashMap</span>(mes, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KVDataBase::saveFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hash_map.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">delete</span> all_raii;</span><br><span class="line">    <span class="built_in">close</span>(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KVDataBase::updateHashMap</span><span class="params">(<span class="type">const</span> Message&amp; mes, LL value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL hash_key = <span class="built_in">get_hash_value</span>(mes.key);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; kv : hash_map[hash_key]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(kv.key, mes.key)) &#123;</span><br><span class="line">            kv.value = value;</span><br><span class="line">            kv.state = mes.state;</span><br><span class="line">            ++inv_num;</span><br><span class="line">            <span class="keyword">if</span> (inv_num &gt;= <span class="number">5</span>) &#123;                   </span><br><span class="line">                <span class="built_in">purge</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    KeyValue tmp;</span><br><span class="line">    tmp.key = <span class="keyword">this</span>-&gt;all_raii-&gt;<span class="built_in">reqMem</span>(mes.key_len); </span><br><span class="line">    <span class="built_in">strcpy</span>(tmp.key, mes.key);</span><br><span class="line">    tmp.value = value;</span><br><span class="line">    tmp.state = mes.state;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; mes.key &lt;&lt; std::endl;</span></span><br><span class="line">    hash_map[hash_key].<span class="built_in">push_back</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KVDataBase::purge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    inv_num = <span class="number">0</span>;</span><br><span class="line">    Message mes;   </span><br><span class="line">    <span class="type">int</span> tmp_fp = <span class="built_in">open</span>(<span class="string">&quot;./tmp.txt&quot;</span>, O_RDWR | O_CREAT | O_TRUNC, <span class="number">0777</span>);   </span><br><span class="line">    <span class="keyword">if</span> (tmp_fp == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;OPEN ERROR!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; hm : hash_map) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; kv : hm.second) &#123;</span><br><span class="line">            <span class="built_in">lseek</span>(fp, kv.value, SEEK_SET);</span><br><span class="line"></span><br><span class="line">            RAII&lt;<span class="type">char</span>&gt; raii;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">KVDBRead</span>(fp, mes, raii);</span><br><span class="line">            <span class="keyword">if</span> (mes.state) &#123;</span><br><span class="line">                <span class="built_in">KVDBWrite</span>(tmp_fp, mes);         </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">saveFile</span>();</span><br><span class="line">    fp = <span class="built_in">open</span>(file_name.<span class="built_in">c_str</span>(), O_RDWR | O_TRUNC | O_CREAT, <span class="number">0777</span>);</span><br><span class="line">    <span class="built_in">lseek</span>(tmp_fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        RAII&lt;<span class="type">char</span>&gt; raii;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">KVDBRead</span>(tmp_fp, mes, raii) &lt;= <span class="number">0</span> || <span class="built_in">KVDBWrite</span>(fp, mes) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">close</span>(tmp_fp);</span><br><span class="line">    <span class="built_in">remove</span>(<span class="string">&quot;./tmp.txt&quot;</span>);</span><br><span class="line">    <span class="built_in">loadFile</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">KVDataBase::KVDBRead</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; fp, Message&amp; mes, RAII&lt;<span class="type">char</span>&gt;&amp; raii)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(fp, &amp;mes.key_len, <span class="built_in">sizeof</span>(<span class="type">int</span>)) &lt;= <span class="number">0</span> ||</span><br><span class="line">        <span class="built_in">read</span>(fp, &amp;mes.value_len, <span class="built_in">sizeof</span>(<span class="type">int</span>)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    mes.key = raii.<span class="built_in">reqMem</span>(mes.key_len);</span><br><span class="line">    mes.value = raii.<span class="built_in">reqMem</span>(mes.value_len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(fp, mes.key, mes.key_len) &lt;= <span class="number">0</span> || </span><br><span class="line">    <span class="built_in">read</span>(fp, mes.value, mes.value_len) &lt;= <span class="number">0</span> ||</span><br><span class="line">    <span class="built_in">read</span>(fp, &amp;mes.state, <span class="built_in">sizeof</span>(mes.state)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">KVDataBase::KVDBWrite</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; fp, Message&amp; mes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">write</span>(fp, &amp;mes.key_len, <span class="built_in">sizeof</span>(mes.key_len)) &lt;= <span class="number">0</span> ||</span><br><span class="line">    <span class="built_in">write</span>(fp, &amp;mes.value_len, <span class="built_in">sizeof</span>(mes.value_len)) &lt;= <span class="number">0</span> ||</span><br><span class="line">    <span class="built_in">write</span>(fp, mes.key, mes.key_len) &lt;= <span class="number">0</span> ||</span><br><span class="line">    <span class="built_in">write</span>(fp, mes.value, mes.value_len) &lt;= <span class="number">0</span> ||</span><br><span class="line">    <span class="built_in">write</span>(fp, &amp;mes.state, <span class="built_in">sizeof</span>(mes.state)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MyLogger-h"><a href="#MyLogger-h" class="headerlink" title="MyLogger.h"></a>MyLogger.h</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Log</span> &#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">char</span>* content;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Logger</span>(<span class="type">const</span> std::string&amp; logger_name = <span class="string">&quot;./logger.txt&quot;</span>);</span><br><span class="line">    ~<span class="built_in">Logger</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getError</span><span class="params">(<span class="type">int</span> x, <span class="type">const</span> std::string&amp; err_pos = <span class="string">&quot;&quot;</span>)</span></span>;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span> = (<span class="type">const</span> Logger&amp; t) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;logger_name = t.logger_name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;fp = <span class="built_in">open</span>(<span class="keyword">this</span>-&gt;logger_name.<span class="built_in">c_str</span>(), O_RDWR | O_CREAT, <span class="number">0777</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;fp == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;Logger Error!&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> fp;</span><br><span class="line">    std::string logger_name;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printPathError</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printKeyError</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printMemoryError</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printOther</span><span class="params">(<span class="type">const</span> std::string&amp; err_pos)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LoggerRead</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; fp, Log&amp; line)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">LoggerWrite</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; fp, <span class="type">char</span>* str, <span class="type">int</span> len)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Mylogger-cpp"><a href="#Mylogger-cpp" class="headerlink" title="Mylogger.cpp"></a>Mylogger.cpp</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyLogger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">Logger::<span class="built_in">Logger</span>(<span class="type">const</span> std::string&amp; logger_name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;logger_name = logger_name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;fp = <span class="built_in">open</span>(<span class="keyword">this</span>-&gt;logger_name.<span class="built_in">c_str</span>(), O_RDWR | O_CREAT, <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;fp == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Logger Error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Logger::~<span class="built_in">Logger</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">close</span>(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::getError</span><span class="params">(<span class="type">int</span> x, <span class="type">const</span> std::string&amp; err_pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">printPathError</span>(); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printKeyError</span>(); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">printMemoryError</span>(); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="built_in">printOther</span>(err_pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::printPathError</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> content[] = <span class="string">&quot;KVDB_INVALID_AOF_PATH\n&quot;</span>;</span><br><span class="line">    <span class="built_in">LoggerWrite</span>(fp, content, <span class="built_in">strlen</span>(content) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::printKeyError</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> content[] = <span class="string">&quot;KVDB_INVALID_KEY\n&quot;</span>;</span><br><span class="line">    <span class="built_in">LoggerWrite</span>(fp, content, <span class="built_in">sizeof</span>(content));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::printMemoryError</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> content[] = <span class="string">&quot;KVDB_NO_SPACE_LEFT_ON_DEVICES\n&quot;</span>;</span><br><span class="line">    <span class="built_in">LoggerWrite</span>(fp, content, <span class="built_in">sizeof</span>(content));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::printOther</span><span class="params">(<span class="type">const</span> std::string&amp; err_pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span>* content = <span class="keyword">new</span> <span class="type">char</span>[err_pos.<span class="built_in">size</span>()];</span><br><span class="line">    <span class="built_in">strcpy</span>(content, err_pos.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">LoggerWrite</span>(fp, content, <span class="built_in">sizeof</span>(content));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::LoggerRead</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; fp, Log&amp; line)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(fp, &amp;line.len, <span class="built_in">sizeof</span>(line.len));</span><br><span class="line">    line.content = <span class="keyword">new</span> <span class="type">char</span>[line.len];</span><br><span class="line">    <span class="built_in">read</span>(fp, line.content, line.len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::LoggerWrite</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; fp, <span class="type">char</span>* content, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">write</span>(fp, &amp;len, <span class="built_in">sizeof</span>(len));;</span><br><span class="line">    <span class="built_in">write</span>(fp, content, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><h5 id="test-cpp"><a href="#test-cpp" class="headerlink" title="test.cpp"></a>test.cpp</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyKVDataBase.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function">KVDataBase <span class="title">db</span><span class="params">(<span class="string">&quot;./text.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> key[<span class="number">3</span>][<span class="number">100</span>];</span><br><span class="line">    <span class="type">char</span> value[<span class="number">3</span>][<span class="number">1000</span>] = &#123; <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;grape&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="type">char</span> tmp[<span class="number">2</span>] = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        tmp[<span class="number">0</span>] += i;</span><br><span class="line">        <span class="built_in">strcpy</span>(key[i], tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    db.<span class="built_in">set</span>(key[<span class="number">0</span>], value[<span class="number">0</span>]);</span><br><span class="line">    db.<span class="built_in">set</span>(key[<span class="number">1</span>], value[<span class="number">1</span>]);</span><br><span class="line">    db.<span class="built_in">set</span>(key[<span class="number">2</span>], value[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, db.<span class="built_in">get</span>(key[<span class="number">2</span>]).<span class="built_in">c_str</span>());</span><br><span class="line">    db.<span class="built_in">del</span>(key[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, db.<span class="built_in">get</span>(key[<span class="number">1</span>]).<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="test2-cpp"><a href="#test2-cpp" class="headerlink" title="test2.cpp"></a>test2.cpp</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyKVDataBase.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> all = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> tmp_fp = <span class="built_in">open</span>(<span class="string">&quot;./text.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="type">void</span>* f;</span><br><span class="line">    Message mes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">read</span>(tmp_fp, &amp;mes.key_len, <span class="built_in">sizeof</span>(<span class="type">int</span>)) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            <span class="built_in">read</span>(tmp_fp, &amp;mes.value_len, <span class="built_in">sizeof</span>(<span class="type">int</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        RAII&lt;<span class="type">char</span>&gt; raii;</span><br><span class="line">        mes.key = raii.<span class="built_in">reqMem</span>(mes.key_len);</span><br><span class="line">        mes.value = raii.<span class="built_in">reqMem</span>(mes.value_len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">read</span>(tmp_fp, mes.key, mes.key_len) &lt; <span class="number">0</span> || </span><br><span class="line">        <span class="built_in">read</span>(tmp_fp, mes.value, mes.value_len) &lt; <span class="number">0</span> ||</span><br><span class="line">        <span class="built_in">read</span>(tmp_fp, &amp;mes.state, <span class="built_in">sizeof</span>(mes.state)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mes.state == <span class="number">0</span>) all++;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;TEST: &quot;</span> &lt;&lt; mes.key &lt;&lt; <span class="string">&#x27;|&#x27;</span> &lt;&lt; mes.value &lt;&lt; <span class="string">&#x27;|&#x27;</span> &lt;&lt; mes.state &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; all &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KV数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解文本和表格数据的联合预训练</title>
      <link href="/2023/09/24/%E7%90%86%E8%A7%A3%E6%96%87%E6%9C%AC%E5%92%8C%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE%E7%9A%84%E8%81%94%E5%90%88%E9%A2%84%E8%AE%AD%E7%BB%83/"/>
      <url>/2023/09/24/%E7%90%86%E8%A7%A3%E6%96%87%E6%9C%AC%E5%92%8C%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE%E7%9A%84%E8%81%94%E5%90%88%E9%A2%84%E8%AE%AD%E7%BB%83/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li>BERT模型是一个大规模的预训练语言模型，能通过无监督学习的方式捕捉文本语法和语义，应用于文本跨度选择问题的理解任务，其中可以使用LM之上的简单分类器来预测答案跨度的边界。</li><li>自由格式的自然语言文本和（半）结构化数据进行联合推理的QA任务，如访问数据库的语义解析，我们为此定制了神经语义解析器去学习NL话语的联合表示和DB表的（半）结构化模式。但是，存储在DB表中的信息显示出强大的底层结构，而现有的LM（例如BERT）仅用于编码自由格式文本。<strong>）不同，语义解析是高度特定于领域的，它可以被公式化为一个通用的答案跨度选择问题，并通过具有额外分类层的预训练模型来解决，神经解析器的体系结构与其底层数据库的结构紧密耦合</strong>。</li><li>在论文中，我们提出了TABERT，这是一种用于联合理解NL文本和（半）结构化表格数据的预训练方法。<ul><li>具体来说，TABERT将表的结构线性化，以与基于Transformer的BERT模型兼容。为了处理大型表格，我们提出了内容快照，这是一种对与输入话语最相关的表格内容子集进行编码的方法。</li></ul></li><li>TABERT可以作为通用编码器插入到神经语义解析器中，以计算话语和表的表示。我们的关键见解是，尽管语义解析器是高度特定于领域的，但大多数系统都依赖于输入话语的表示和表模式来促进后续生成DB查询，并且这些表示可以由TABERT提供，而不考虑解析任务的领域。</li><li>我们将TABERT应用于两种不同的语义解析范式：（1）SPIDER文本到SQL数据集上的经典监督学习设置，其中TABERT与使用并行NL语句和标记DB查询的特定任务解析器一起进行了微调；（2）一个具有挑战性的弱监督学习基准WIKITABLEQUESTIONS，其中系统必须从其执行结果中推断潜在的DB查询。<strong>PS</strong>：TABERT在两种场景中都是有效的，表明它是计算NL话语和DB表的上下文表示的解析器原始编码器的替代品</li></ul><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li>表上的语义分析语义分析解决了将NL话语u翻译成形式意义表示（MR）z的任务。<ul><li>给定一个话语及其相关联的表，神经语义解析器根据话语令牌的向量表示和表的结构化模式生成DB查询。</li></ul></li><li>掩码语言模型<ul><li>其目的是从通过随机屏蔽x中的某些令牌而创建的“损坏”上下文中恢复x中的原始令牌。</li></ul></li><li>TABERT使用Transformar模型对pθ（xm|x）进行参数化。在预训练阶段，BERT在大规模文本上下文上最大化pθ（xm|x）。在微调阶段，将先前的模型用作编码器来计算输入NL令牌的表示，并将其参数与其他任务特定的神经组件联合调整。</li></ul><h3 id="表：文本和表格数据上的学习联合表示"><a href="#表：文本和表格数据上的学习联合表示" class="headerlink" title="表：文本和表格数据上的学习联合表示"></a>表：文本和表格数据上的学习联合表示</h3><ul><li>内容快照：使用表内容而不仅仅是列名，因为DB表可能有大量行，其中只有很少的行与回答输入话语实际相关。使用资源密集的Transformer对所有内容进行En编码在计算上很难处理，而且可能没有必要。<ul><li>一个简单的策略：选取和NL相关性最高的K行（K&gt;1），若K&#x3D;1，则选取每列最相关的单元格值来创建合成行。</li></ul></li><li>行线性化：列名|类型|单元格值（使用[SEP]符号分隔）</li><li>垂直自我注意机制：行矢量是单独计算的，为使其信息在不同单元格间流动。</li><li>无监督学习：对NL文本，使用marked language model建模，屏蔽率为15%。对于学习列表示，我们设计了两个目标，其动机是直觉，即列表示应包含列的一般信息（例如，其名称和数据类型）和与NL上下文相关的代表性单元格值。首先，掩蔽列预测（MCP）目标鼓励模型恢复掩蔽列的名称和数据类型。接下来，使用辅助的单元格值恢复（CVR）目标来确保在额外的垂直自我关注层之后，内容快照中代表性单元格值的信息被保留。（一个单元格可能有多个token，需要用基于跨度的token）</li></ul><h3 id="表上的语义解析"><a href="#表上的语义解析" class="headerlink" title="表上的语义解析"></a>表上的语义解析</h3><ul><li>监督语义分析</li><li>弱监督语义分析</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>TABERT，一种用于联合理解文本和表格数据的预训练编码器。我们展示了使用TABERT作为通用特征表示层的语义解析器 在两个基准上取得了强有力的成果。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 文章效果展示 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 演示 </tag>
            
            <tag> 展示 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BootStrap</title>
      <link href="/2023/07/31/BootStrap/"/>
      <url>/2023/07/31/BootStrap/</url>
      
        <content type="html"><![CDATA[<h3 id="下载BootStrap（v3版本）"><a href="#下载BootStrap（v3版本）" class="headerlink" title="下载BootStrap（v3版本）"></a><a href="https://github.com/twbs/bootstrap/releases/download/v3.4.1/bootstrap-3.4.1-dist.zip">下载BootStrap（v3版本）</a></h3><h3 id="创建static目录"><a href="#创建static目录" class="headerlink" title="创建static目录"></a>创建static目录</h3><p>__static<br>  |__css<br>  |__image<br>  |__js<br>  |__plugins<br>    |__bootsrap-3.4.1</p><h3 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a><a href="https://v3.bootcss.com/css/#grid">栅格系统</a></h3><ul><li>网页划分区域的时候要基于此来做。</li></ul><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><h5 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.col-lg-</span><br><span class="line">.col-md-</span><br><span class="line">.col-sm-</span><br></pre></td></tr></table></figure><p>三者支持的最小宽度不一样，小于最小宽度时排版会出现变化</p><h5 id="非响应式"><a href="#非响应式" class="headerlink" title="非响应式"></a>非响应式</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">col-xs-</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>直接去官方文档CV，然后再根据自己的需求自定制。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> BootStrap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2023/07/07/MySQL/"/>
      <url>/2023/07/07/MySQL/</url>
      
        <content type="html"><![CDATA[<h3 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h3><p>MySQL的安装&amp;&amp;配置&amp;&amp;启动&amp;&amp;关闭&amp;&amp;指令&amp;&amp;python第三方模块，发送指令并获取MySQL返回的结果</p><h3 id="MySQL的环境搭建"><a href="#MySQL的环境搭建" class="headerlink" title="MySQL的环境搭建"></a>MySQL的环境搭建</h3><h4 id="MySQL的配置"><a href="#MySQL的配置" class="headerlink" title="MySQL的配置"></a>MySQL的配置</h4><p><img src="https://s2.loli.net/2023/07/07/dBOYWQqPVKrHj7R.png"></p><h4 id="MySQL的初始化"><a href="#MySQL的初始化" class="headerlink" title="MySQL的初始化"></a>MySQL的初始化</h4><ul><li>打开终端&amp;&amp;以管理员权限运行</li><li>输入初始化命令<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;E:\Pycharm\mysql-5.7.31-winx64\bin\mysqld.exe&quot; --initialize-insecure</span><br></pre></td></tr></table></figure></li></ul><h4 id="MySQL启动"><a href="#MySQL启动" class="headerlink" title="MySQL启动"></a>MySQL启动</h4><ul><li>两种方式<ul><li>临时启动（不建议）：<br>直接在命令行中输入<code>E:\Pycharm\mysql-5.7.31-winx64\bin\mysqld.exe</code></li><li>制作成windows服务，利用服务来关闭和开启。<br>执行命令<code>&quot;E:\Pycharm\mysql-5.7.31-winx64\bin\mysqld.exe&quot; --install mysql5731</code><br>启动服务：<code>net start mysql5731</code><br>关闭服务：<code>net stop mysql5731</code></li></ul></li></ul><h4 id="连接并测试MySQL"><a href="#连接并测试MySQL" class="headerlink" title="连接并测试MySQL"></a>连接并测试MySQL</h4><p><img src="https://s2.loli.net/2023/07/07/ZDNGWhFHv1cKBrd.png"></p><h4 id="指令：设置密码"><a href="#指令：设置密码" class="headerlink" title="指令：设置密码"></a>指令：设置密码</h4><p><code>set password = passowrd(&quot;xxxxx&quot;);</code></p><h5 id="忘记密码"><a href="#忘记密码" class="headerlink" title="忘记密码"></a>忘记密码</h5><ul><li>在配置文件<code>my.ini</code>中加上<code>skip-grant-tables=1</code>,然后重新启动mysql</li><li>再次登录mysql，最后重新设置密码。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use mysql</span><br><span class="line">update user set authentication_string = password(&#x27;password&#x27;),passwoed_last_chenged=now() where user=&#x27;root&#x27;;</span><br></pre></td></tr></table></figure></li><li>最后删去配置文件中加的东西，重新启动并登录mysql</li></ul><h4 id="指令：查看已有文件夹"><a href="#指令：查看已有文件夹" class="headerlink" title="指令：查看已有文件夹"></a>指令：查看已有文件夹</h4><p><code>show databases;</code></p><h4 id="MySQL退出"><a href="#MySQL退出" class="headerlink" title="MySQL退出"></a>MySQL退出</h4><p><code>exit;</code></p><h4 id="数据库管理（文件夹）"><a href="#数据库管理（文件夹）" class="headerlink" title="数据库管理（文件夹）"></a>数据库管理（文件夹）</h4><ul><li>创建数据库（文件夹）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database 数据库名字 DEFAULT CHARSET utf8 COLLATE utf8_general_ci;</span><br></pre></td></tr></table></figure></li><li>删除数据库（文件夹）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop database 要删除的数据库的名字；</span><br></pre></td></tr></table></figure></li><li>进入数据库（文件夹）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use 数据库名字；</span><br></pre></td></tr></table></figure><ul><li>查看文件夹下所有数据表（文件）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  show tables：</span><br><span class="line">  ```  </span><br><span class="line">- 表中常用数据类型</span><br><span class="line">  - 表示整数（只有取值范围的区别）</span><br><span class="line">    - tinyint </span><br><span class="line">      有符号，取值范围-128~127（默认）</span><br><span class="line">      无符号，取值范围0~255（在tinyint后面加unsigned，下面的同理）</span><br><span class="line">    - int</span><br><span class="line">    - bigint</span><br><span class="line">  - 表示浮点数（三者用法均一样）</span><br><span class="line">    `类型(m, d)` </span><br><span class="line">    - float （不精准）</span><br><span class="line">    - double （不精准）</span><br><span class="line">    - decimal（精准）</span><br><span class="line">      ![](https://s2.loli.net/2023/07/19/n2VLYXGuTZ6zHDk.png)</span><br><span class="line">  - 字符串</span><br><span class="line">    - **char(m)** 速度快，m最大为255</span><br><span class="line">      定长字符串，例：`char(11)`，固定用11个字符串存储，无论是否有11个字符。 </span><br><span class="line">    - **varchar(m)** 节省空间，最大为65535字节，与机器的编码有关</span><br><span class="line">      变长字符串，`varchar(11)`，11是字符串最大容量。</span><br><span class="line">    - **text**</span><br><span class="line">      ![](https://s2.loli.net/2023/07/19/OdJotNn7Ls6Z2hk.png) </span><br><span class="line">    - mediumtext</span><br><span class="line">      范围为2^24-1个字符 </span><br><span class="line">    - longtext</span><br><span class="line">      范围为2^32-1个字符</span><br><span class="line">    - **datetime**</span><br><span class="line">      YYYY-MM-DD HH:MM:SS </span><br><span class="line">    - **date**</span><br><span class="line">      YYYY-MM-DD  </span><br><span class="line">- 创建表</span><br><span class="line">  ```sql</span><br><span class="line">  create table 表名称(  </span><br><span class="line">    列名称 类型，</span><br><span class="line">    列名称 类型，</span><br><span class="line">    列名称 类型</span><br><span class="line">    )default charset=utf8;</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2023/07/19/kDlKVsdAneGrfpt.png"></li><li>新增（删除）列<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名</span><br><span class="line"><span class="keyword">add</span> 列名 列的数据类型 要求;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">column</span> 列名;</span><br><span class="line"><span class="operator">=</span><span class="operator">=</span> 其中关键字<span class="keyword">column</span>可以省略</span><br></pre></td></tr></table></figure></li><li>改变列的位置<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名</span><br><span class="line">modify</span><br><span class="line">列名<span class="number">1</span> 列的数据类型</span><br><span class="line"><span class="keyword">first</span><span class="operator">/</span>after</span><br><span class="line">列名<span class="number">2</span> 列的数据类型; <span class="operator">=</span><span class="operator">=</span>列名<span class="number">2</span>可选</span><br></pre></td></tr></table></figure></li><li>展示表格式<br><code>desc 表名称;</code></li><li>删除表<br><code>drop table 表名称;</code></li></ul></li></ul><h4 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h4><ul><li>插入数据<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 数据表名称</span><br><span class="line">(列名称<span class="number">1</span>, 列名称<span class="number">2</span>，……) </span><br><span class="line"><span class="keyword">values</span></span><br><span class="line">(数据<span class="number">1</span>, 数据<span class="number">2</span>, ……),</span><br><span class="line">(数据<span class="number">1</span>, 数据<span class="number">2</span>, ……), </span><br><span class="line">……; </span><br><span class="line"><span class="operator">=</span><span class="operator">=</span> 插入多少行数据就写多少行<span class="keyword">values</span></span><br></pre></td></tr></table></figure></li><li>查看数据<br><code> select * from 表名称;</code></li><li>删除数据<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件;</span><br><span class="line">例子：</span><br><span class="line">  <span class="keyword">delete</span> <span class="keyword">from</span> tables <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">3</span> <span class="keyword">and</span> name <span class="operator">=</span> &quot;XXX&quot;;</span><br><span class="line">  <span class="keyword">delete</span> <span class="keyword">from</span> tables <span class="keyword">where</span> id <span class="operator">!=</span> <span class="number">3</span> <span class="keyword">or</span> name <span class="operator">=</span> &quot;XXX&quot;;</span><br><span class="line">  <span class="keyword">delete</span> <span class="keyword">from</span> tables <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">3</span> <span class="keyword">and</span> name <span class="operator">=</span> &quot;XXX&quot;;</span><br><span class="line">  <span class="keyword">delete</span> <span class="keyword">from</span> tables <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">5</span>); <span class="operator">=</span><span class="operator">=</span> 删除的是<span class="number">1</span>和<span class="number">5</span>，不是<span class="number">1</span><span class="operator">~</span><span class="number">5</span>。</span><br></pre></td></tr></table></figure></li><li>修改数据<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">update</span> 表名 <span class="keyword">set</span> 列<span class="operator">=</span>值，列<span class="operator">=</span>值;</span><br><span class="line">    <span class="keyword">update</span> 表名 <span class="keyword">set</span> 列<span class="operator">=</span>值 <span class="keyword">where</span> 条件;</span><br><span class="line">    ```  </span><br><span class="line"></span><br><span class="line">#### 案例：员工管理</span><br><span class="line">##### 使用MySQL内置工具</span><br><span class="line"><span class="operator">-</span> 创建数据库unicom</span><br><span class="line"><span class="operator">-</span> 创建一张表admin</span><br></pre></td></tr></table></figure>  表名：admin<br>  列：<br>  id，int，自增，主键<br>  username 字符串 不为空<br>  password 字符串 不为空<br>  mobile 字符串 不为空  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##### 使用Python之pymysql操作表中数据</span><br><span class="line">- 创建数据</span><br><span class="line">  ```python</span><br><span class="line">  import pymysqk</span><br><span class="line"></span><br><span class="line">  # 1.链接MySQL</span><br><span class="line">  connection = pymysql.connect(host=&#x27;localhost&#x27;, </span><br><span class="line">  port=3306, </span><br><span class="line">  user=&#x27;root&#x27;, password=&quot;031123hlm2020&quot;, </span><br><span class="line">  db=&#x27;unicom&#x27;, charset=&#x27;utf8&#x27;)</span><br><span class="line">  cursor = connection.cursor(cursor=pymysql.cursors.DictCursor)</span><br><span class="line"></span><br><span class="line">  # 2.发送指令（不能用字符串格式化去做SQL的拼接，安全隐患SQL注入</span><br><span class="line">  # 1）添加单个数据</span><br><span class="line">  cursor.execute(&quot;insert into admin(username, password,mobile) values(&#x27;Mike&#x27;, &#x27;123456&#x27;, &#x27;18300144192&#x27;)&quot;)</span><br><span class="line"></span><br><span class="line">  # cursor.execute(&quot;delete from admin where id &lt;= 2&quot;)</span><br><span class="line"></span><br><span class="line">  sql = &quot;insert into admin(username, password,mobile) values(%s, %s, %s)&quot;</span><br><span class="line">  cursor.execute(sql, [user, passowrd, mobile])</span><br><span class="line"></span><br><span class="line">  sql = &quot;insert into admin(username, password,mobile) values(%(n1)s, %(n2)s, %(n3)s)&quot;</span><br><span class="line">  cursor.execute(sql, [&quot;n1&quot;: &#x27;Mike&#x27;, &quot;n2&quot;: &#x27;123456&#x27;, &quot;n3&quot;: &#x27;18300144192&#x27;])</span><br><span class="line"></span><br><span class="line">  # 2）添加多个数据</span><br><span class="line">  connection.commit()</span><br><span class="line"></span><br><span class="line">  # 3.关闭连接</span><br><span class="line">  cursor.close()</span><br><span class="line">  connection.close()</span><br></pre></td></tr></table></figure></li><li>我们每次只需要改变第二部分的代码即可实现增删改查的要求</li><li>查询数据、删除数据、修改数据<ul><li>将sql的字符串换成相应的操作即可。</li></ul></li></ul><h6 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h6><ul><li>在进行创建数据、删除数据和修改数据时，一定要commit，不然数据库没有数据</li><li>在查询时，不需要commit，执行fetchall&#x2F;fetchone<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.链接MySQL</span></span><br><span class="line">connection = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">3306</span>, user=<span class="string">&#x27;root&#x27;</span>, password=<span class="string">&quot;031123hlm2020&quot;</span>, db=<span class="string">&#x27;unicom&#x27;</span>, charset=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">cursor = connection.cursor(cursor=pymysql.cursors.DictCursor)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.执行查询指令</span></span><br><span class="line"><span class="comment"># sql = &quot;select * from admin where id &lt; %s&quot;</span></span><br><span class="line"><span class="comment"># cursor.execute(sql, [4])</span></span><br><span class="line">sql = <span class="string">&quot;select * from admin&quot;</span></span><br><span class="line">cursor.execute(sql)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有数据， 得到的是列表套字典：[&#x27;XXX&#x27;: &#x27;XX&#x27;, ]，如果没有数据则是空列表</span></span><br><span class="line"><span class="comment"># 应用场景：知乎热榜</span></span><br><span class="line">data_list = cursor.fetchall()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取符合条件的第一条数据， 得到的是字典：&#x27;XXX&#x27;: &#x27;XX&#x27;，如果没有数据则为null</span></span><br><span class="line"><span class="comment"># 应用场景：查询数据库中是否存在某个用户名和密码</span></span><br><span class="line">data = cursor.fetchone()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row_dict <span class="keyword">in</span> data_list:</span><br><span class="line">    <span class="built_in">print</span>(row_dict)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.关闭连接</span></span><br><span class="line">cursor.close()</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure></li><li>对于SQL语句不要用Python的字符串格式化拼接（会被SQL注入），一定要用execute+参数</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自学Django总结</title>
      <link href="/2023/06/13/%E8%87%AA%E5%AD%A6Django%E6%80%BB%E7%BB%93/"/>
      <url>/2023/06/13/%E8%87%AA%E5%AD%A6Django%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>本文章总结自b站的django3教程。</p><h4 id="Django的安装"><a href="#Django的安装" class="headerlink" title="Django的安装"></a>Django的安装</h4><ul><li>打开Pycharm，在终端中输入<code>pip install django</code>即可安装成功。</li></ul><h4 id="创建项目（命令行）"><a href="#创建项目（命令行）" class="headerlink" title="创建项目（命令行）"></a>创建项目（命令行）</h4><ul><li>同样是在终端中，输入<code>django-admin startproject 你的项目名称</code>即可创建成功。</li></ul><h4 id="创建项目（Pycharm）"><a href="#创建项目（Pycharm）" class="headerlink" title="创建项目（Pycharm）"></a>创建项目（Pycharm）</h4><p>特殊说明：</p><ul><li>通过命令行创建的是标准的。</li><li>通过Pycharm创建的多了一些东西，<br> 。创建了一个templates目录（删除）<br> 。在settings.py中，多了一句话，意思是以后找模板的时候优先去templates模板目录下找。<br> <img src="https://s2.loli.net/2023/06/22/sVwmuo7bCN3rnPE.png"></li></ul><h4 id="默认文件"><a href="#默认文件" class="headerlink" title="默认文件"></a>默认文件</h4><p><img src="https://s2.loli.net/2023/06/13/CjQySwu1pheBYNE.png"></p><h4 id="app的创建和说明"><a href="#app的创建和说明" class="headerlink" title="app的创建和说明"></a>app的创建和说明</h4><ul><li>此app非彼app，这个app是指同一项目下实现不同功能的单独的个体。</li></ul><p><img src="https://s2.loli.net/2023/06/13/F27EOhDlujGcPQX.png"><br><img src="https://s2.loli.net/2023/06/13/ULGSQY7qVrMHwvW.png"></p><ul><li>在终端中输入<code>python manage.py startapp app名称</code>即可创建成功。<strong>注意：这里要先进入你的项目里面，再输入命令。</strong></li></ul><h4 id="启动运行Django"><a href="#启动运行Django" class="headerlink" title="启动运行Django"></a>启动运行Django</h4><h5 id="注册app"><a href="#注册app" class="headerlink" title="注册app"></a>注册app</h5><ul><li>在项目的<code>settings.py</code>中找到<code>INSTALLED_APPS</code>，在其下加上<code>&#39;（app名称）.apps.（app名称）Config&#39;,</code>，后一个app名称开头为大写。</li></ul><h5 id="编写URL和视图函数的对应关系"><a href="#编写URL和视图函数的对应关系" class="headerlink" title="编写URL和视图函数的对应关系"></a>编写URL和视图函数的对应关系</h5><ul><li>在<code>urls.py</code>中建立对应的关系<code>path(&#39;index/&#39;, admin.site.urls),</code>，函数写在app中的<code>views.py</code>中。</li><li>然后在<code>urls.py</code>中导入（<code>from app名称 import views</code>），导入包时会报错，可以忽略。</li></ul><h5 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h5><ul><li>在终端中输入<code>python manage.py runserver</code></li></ul><h4 id="模板和静态文件"><a href="#模板和静态文件" class="headerlink" title="模板和静态文件"></a>模板和静态文件</h4><h5 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h5><ul><li>本质上是将函数和urls对应起来<br><img src="https://s2.loli.net/2023/06/21/YgmqoAaBH4QJPpd.png"></li></ul><h5 id="templates模板"><a href="#templates模板" class="headerlink" title="templates模板"></a>templates模板</h5><ul><li>在views.py中写函数 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_list</span>(<span class="params">request</span>):</span><br><span class="line">     <span class="keyword">return</span> render(request, <span class="string">&quot;user_list.html&quot;</span>)</span><br></pre></td></tr></table></figure></li><li>程序会优先到当前app文件下得templates目录中寻找<code>user_list.html</code>文件，如果找不到，则会根据app得注册顺序，逐一去他们的templates目录下找。</li></ul><h5 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h5><ul><li>在开发过程中，图片、CSS、JS都会当作静态文件处理。   </li><li>静态文件要放在名为<code>static</code>目录下，<code>static</code>目录中：<br>—static<br> |<br> |———— css<br> |<br> |———— img<br> |<br> |———— js<br> |<br> |———— plugins</li></ul><p> ps：<code>&lt;img src=&quot;/static/img/1.png&quot; alt=&quot;&quot;&gt;</code>是html是放置图片的语法。但是，在django中一般不用这个语法。</p><ul><li>在Django中所有静态文件都应该如下图写：<br><img src="https://s2.loli.net/2023/06/21/y7iCwQheEOUN3sH.png"></li></ul><h4 id="Django模板语法"><a href="#Django模板语法" class="headerlink" title="Django模板语法"></a>Django模板语法</h4><ul><li><p><strong>本质上是在HTML中写一些占位符，由数据对这些占位符进行替换和处理。</strong><br><img src="https://s2.loli.net/2023/06/22/n2x1yAiblgMFI5h.png"></p></li><li><p>所有在python中要加括号的，在模板语法中都不需要加括号（会自动加）。</p></li><li><p>列表语法<br><img src="https://s2.loli.net/2023/06/22/6Ai73STJskywxbe.png"></p></li><li><p>字典语法</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">其中i为键（key），j为值（value）,</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    &#123;% for i, j in dict.items %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; i &#125;&#125; &#123;&#123; j &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    &#123;% for i in dict.key %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; i &#125;&#125;<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    &#123;% for i in dict.value %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; i &#125;&#125;<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>html语法<br><code>&lt;ul&gt;&lt;/ul&gt;是退格，&lt;li&gt;&lt;/li&gt;相当于markdown中的‘-’，&lt;hr/&gt;是横线</code></li></ul></li><li><p>列表套字典<br><img src="https://s2.loli.net/2023/06/22/4XLqevlzJTYQGwU.png"></p></li><li><p>模板语法还支持条件语法</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if power_list.0 == &quot;管理员&quot; %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>YES<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">&#123;% elif power_list.1 == &quot;用户&quot;%&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>YES<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">&#123;% else %&#125; </span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>NO<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="案例（新闻中心）"><a href="#案例（新闻中心）" class="headerlink" title="案例（新闻中心）"></a>案例（新闻中心）</h5><ol><li>在<code>urls.py</code>中创建<code>path(&#39;news/&#39;, views.news),</code></li><li>在<code>views.py</code>中定义函数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">news</span>(<span class="params">request</span>):</span><br><span class="line"> <span class="comment"># 1.我们可以将新闻改为字典或列表进行展示，或者去数据库找，也可以利用爬虫爬取别的新闻</span></span><br><span class="line"> <span class="comment"># 2.向http://www.chinaunicom.com.cn/api/article/NewsByIndex/2/2023/06/news发送请求</span></span><br><span class="line"> <span class="comment"># 3.使用第三方模块：requests，注意不要混淆requests和request，前者是模块，后者是参数</span></span><br><span class="line"> <span class="keyword">import</span> requests</span><br><span class="line"> headers = &#123;<span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/&quot;</span></span><br><span class="line">                          <span class="string">&quot;114.0.0.0 Safari/537.36 Edg/114.0.1823.51&quot;</span>&#125;</span><br><span class="line"> res = requests.get(<span class="string">&quot;http://www.chinaunicom.com.cn/api/article/NewsByIndex/2/2023/06/news&quot;</span>, headers=headers)</span><br><span class="line"> data_list = res.json()</span><br><span class="line"> <span class="keyword">return</span> render(request, <span class="string">&quot;news.html&quot;</span>, &#123;<span class="string">&quot;news_list&quot;</span>: data_list&#125;)</span><br></pre></td></tr></table></figure></li><li>在<code>templates</code>目录下，创建<code>news.html</code><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>新闻中心<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    &#123;% for i in news_list %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; i.news_title &#125;&#125; 时间：&#123;&#123; i.post_time &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="请求和响应-views-py"><a href="#请求和响应-views-py" class="headerlink" title="请求和响应(views.py)"></a>请求和响应(views.py)</h4><h5 id="探幽request（请求）"><a href="#探幽request（请求）" class="headerlink" title="探幽request（请求）"></a>探幽request（请求）</h5><ul><li>request是一个对象，封装了用户发送过来的所有请求相关数据。 </li><li>获取请求方式（GET&#x2F;POST）：<code>request.method</code></li><li>在URL上传递值（…&#x2F;?n1&#x3D;123&amp;n2&#x3D;999）：<code>request.GET</code></li><li>在请求体中提交数据<code>request.POST</code></li></ul><h5 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h5><ul><li><code>return HttpResponse(&quot;&quot;)</code>，内容字符串返回给请求者。</li><li><code>return render(request, &#39;&#39;, &#123;&quot;&quot;: &quot;&quot;&#125;)</code>,读取html中的内容+渲染（替换），然后生成字符串返回给请求者。</li><li><code>redirect</code>（让浏览器重定向到其他网页）<br><img src="https://s2.loli.net/2023/06/23/t9OowvACcL75bQT.png"><ul><li>语法：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render, HttpResponse, redirect</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">request</span>):</span><br><span class="line">  <span class="keyword">return</span> redirect(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="案例（用户登录）"><a href="#案例（用户登录）" class="headerlink" title="案例（用户登录）"></a>案例（用户登录）</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># urls.py</span></span><br><span class="line">    <span class="comment"># 用户登录</span></span><br><span class="line">    path(<span class="string">&#x27;login/&#x27;</span>, views.login),</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># views.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&quot;login.html&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># print(request.POST)</span></span><br><span class="line">        user_name = request.POST[<span class="string">&quot;user&quot;</span>]</span><br><span class="line">        user_password = request.POST[<span class="string">&quot;pwd&quot;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> user_name == <span class="string">&quot;admin&quot;</span> <span class="keyword">and</span> user_password == <span class="string">&quot;123&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">&quot;http://www.chinaunicom.com.cn&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> render(request, <span class="string">&quot;login.html&quot;</span>,</span><br><span class="line">             &#123;<span class="string">&quot;login_failed&quot;</span>: <span class="string">&quot;登录失败，请重新登录&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>用户登录<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/login/&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    &#123;% csrf_token %&#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;用户名&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;密码&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color: red;&quot;</span>&gt;</span>&#123;&#123; login_failed &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="orm-连接MySQL的模块"><a href="#orm-连接MySQL的模块" class="headerlink" title="orm-连接MySQL的模块"></a>orm-连接MySQL的模块</h4><ul><li>MySQL数据库+pymysql</li><li>Django开发操作更加简单，内部提供了orm框架<br><img src="https://s2.loli.net/2023/06/23/ZpltGNA2UsQJY4D.png"></li></ul><h5 id="安装第三方模块"><a href="#安装第三方模块" class="headerlink" title="安装第三方模块"></a>安装第三方模块</h5><p><code>pip install mysqlclient</code></p><h5 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h5><p>ORM可以帮助我们做两件事：</p><ul><li>创建、修改、删除数据库中的表（不用写SQL语句），<strong>但是无法创建数据库</strong></li><li>操作表中的数据（不用写SQL语句）</li></ul><h5 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h5><ul><li>启动MySQL服务</li><li>自带工具创建数据库</li></ul><h5 id="Django连接数据库"><a href="#Django连接数据库" class="headerlink" title="Django连接数据库"></a>Django连接数据库</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在setting.py中找到DATABASES并将其注释</span></span><br><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;xxx&#x27;</span>, <span class="comment"># 数据库名字</span></span><br><span class="line">        <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;root&#x27;</span>, <span class="comment"># 用户名</span></span><br><span class="line">        <span class="string">&#x27;PASSWORD&#x27;</span>: <span class="string">&#x27;xxx&#x27;</span>, <span class="comment"># 密码</span></span><br><span class="line">        <span class="string">&#x27;HOST&#x27;</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="comment"># 哪台机器安装了MySQL </span></span><br><span class="line">        <span class="string">&#x27;POST&#x27;</span>: <span class="number">3306</span>, <span class="comment"># 端口 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Django操作表"><a href="#Django操作表" class="headerlink" title="Django操作表"></a>Django操作表</h5><p>在app中的models.py中操作</p><ul><li>创建表<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserInfo</span>(models.Model):</span><br><span class="line">  name = models.CharField(max_length=<span class="number">32</span>)</span><br><span class="line">  password = models.CharField(max_length=<span class="number">64</span>)</span><br><span class="line">  age = models.IntegerField()</span><br></pre></td></tr></table></figure><ul><li><p>执行命令</p><ul><li><code>python manage.py makemigrations</code></li><li><code>python manage.py migrate</code></li></ul></li><li><p>增加表只需要重复执行上述命令即可，但如果想要在已有表上增加一项内容则会出现问题-&gt;在原有表上增加一项后，该项内的值应该为多少？</p><ul><li>django提供了两个解决方案：1）在执行命令之后选择赋值；2）给予一个默认值<code>age = models.IntegerField(default=0)</code>或者为空<code>age = models.IntegerField(null=True, blank=True)</code>。</li></ul></li></ul></li><li>删除表<ul><li>将models.py中的类删除或者注释，然后执行上述命令即可。</li></ul></li><li>修改表<ul><li>将类中的内容注释，然后执行上述命令即可。</li></ul></li></ul><h5 id="Django增删改查（操作表中的数据）"><a href="#Django增删改查（操作表中的数据）" class="headerlink" title="Django增删改查（操作表中的数据）"></a>Django增删改查（操作表中的数据）</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class UserInfo(models.Model):</span><br><span class="line">    name = models.CharField(max_length=32)</span><br><span class="line">    password = models.CharField(max_length=64)</span><br><span class="line">    age = models.IntegerField()</span><br></pre></td></tr></table></figure><ul><li>增<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建数据</span></span><br><span class="line">UserInfo.objects.create(title=<span class="string">&quot;销售部&quot;</span>)</span><br></pre></td></tr></table></figure></li><li>删<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除数据</span></span><br><span class="line"><span class="comment"># 将表中满足id=3和xx=xx的所有数据删掉</span></span><br><span class="line">UserInfo.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=<span class="number">3</span>).<span class="built_in">filter</span>().delete()  </span><br><span class="line"><span class="comment"># 将表中所有数据全部删掉</span></span><br><span class="line">UserInfo.objects.<span class="built_in">all</span>().delete()  </span><br></pre></td></tr></table></figure></li><li>改<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新数据</span></span><br><span class="line"><span class="comment"># UserInfo.objects.filter(id=yyy).update(password=&quot;xxx&quot;)</span></span><br><span class="line"><span class="comment"># UserInfo.objects.filter(name=&quot;yyy&quot;).update(age=xxx)</span></span><br></pre></td></tr></table></figure></li><li>查<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取数据</span></span><br><span class="line"><span class="comment"># data_list = [行(对象)，行(对象)，行(对象),……，行(对象)] QuerySet类型</span></span><br><span class="line"><span class="comment"># data_list = UserInfo.objects.all()</span></span><br><span class="line">data_list = UserInfo.objects.<span class="built_in">filter</span>()</span><br><span class="line"><span class="comment"># 遍历取数据</span></span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> data_list:</span><br><span class="line">    <span class="built_in">print</span>(obj.<span class="built_in">id</span>, obj.name, obj.password, obj.age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果数据只有一行，通过下面的方式获得的row_obj就是一个对象而不是QuerySet</span></span><br><span class="line"><span class="comment"># row_obj = UserInfo.objects.filter(id=1).first()</span></span><br><span class="line"><span class="comment"># row_obj = UserInfo.objects.filter(id=1)[0]</span></span><br><span class="line"><span class="comment"># 也可以取第二行的数据</span></span><br><span class="line">row_obj = UserInfo.objects.first(<span class="built_in">id</span>=<span class="number">2</span>).first()</span><br></pre></td></tr></table></figure></li></ul><h4 id="员工管理系统"><a href="#员工管理系统" class="headerlink" title="员工管理系统"></a>员工管理系统</h4><h5 id="创建项目和app"><a href="#创建项目和app" class="headerlink" title="创建项目和app"></a>创建项目和app</h5><h5 id="设计表结构"><a href="#设计表结构" class="headerlink" title="设计表结构"></a>设计表结构</h5><p><img src="https://cdn.jsdelivr.net/gh/HuangLM03/BlogImg@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-30%20132510.png"></p><ul><li>员工应该有一列数据为所属部门，但是部门又是一个表，那么这列数据应该存部门名称还是部门ID？<ul><li>存ID是数据库范式，常见开发都如此。【节省开销】</li><li>存名称是查询数据量大的公司才如此，如果存ID需要连表，耗时较长。【加速查找，允许数据冗余】</li></ul></li><li>部门ID需不需要约束？<ul><li>需要，只能是部门表中存在的ID<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 无约束写法</span></span><br><span class="line">depart_id = models.BigIntegerField(verbose_name=<span class="string">&#x27;部门ID&#x27;</span>)</span><br><span class="line"><span class="comment"># 约束写法</span></span><br><span class="line"><span class="comment"># to表示与哪张表关联，to_field与哪一列关联</span></span><br><span class="line"><span class="comment"># Django自动将depart变成depart_id</span></span><br><span class="line">depart = models.ForeignKey(to=<span class="string">&#x27;Department&#x27;</span>, to_field=<span class="string">&#x27;id&#x27;</span>)</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/HuangLM03/BlogImg@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-07-30%20140957.png"></li></ul></li></ul><h5 id="生成数据库"><a href="#生成数据库" class="headerlink" title="生成数据库"></a>生成数据库</h5><h5 id="部门列表展示（静态文件管理）"><a href="#部门列表展示（静态文件管理）" class="headerlink" title="部门列表展示（静态文件管理）"></a>部门列表展示（静态文件管理）</h5><ul><li>用最原始的方法做【了解内部原理】，其实Django中提供了Form和MoForm组件【非常方便】。</li></ul><h6 id="部门列表"><a href="#部门列表" class="headerlink" title="部门列表"></a>部门列表</h6><p>1.写url+views</p><h4 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h4><p>1.在<code>templates</code>目录下创建<code>layout.html</code>，将重复性内容写到<code>layout.html</code>内，需要修改的地方用占位符<code>&#123;% block contnet %&#125; &#123;% endblock %&#125;</code>占位。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    &lt;% block css %&gt;</span><br><span class="line">    &lt;% endblock %&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;% block content %&#125;</span><br><span class="line">    &#123;% endblock %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.在html文件中使用模板的格式：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% extends &#x27;layout.html&#x27; %&#125;</span><br><span class="line">&#123;% block 占位符名字 %&#125;</span><br><span class="line"><span class="comment">&lt;!-- 这里写自己的内容 --&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><h4 id="Form和ModelForm"><a href="#Form和ModelForm" class="headerlink" title="Form和ModelForm"></a>Form和ModelForm</h4><ul><li>对于新建数据来说，用原始方式则用户提交的数据没有校验，没有错误提示，且开发时每一个字段都需要我们重新写一遍，关联的数据需要手动获取并循坏展示在页面。</li><li>Django中提供了两个组件Form和ModelForm，一般都采用ModelForm。</li><li>ModelForm：针对数据库中的某个表</li><li>ModelForm的具体例子<ul><li>UserModelForm类是固定格式，其中fields中写自己需要的数据库的字段的名称，__init__中设置数据的格式。</li><li>实例化UserModelForm时，如果不带instance，则用户提交的数据会默认为新增数据，否则为修改instance的数据。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserModelForm</span>(forms.ModelForm):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = models.UserInfo</span><br><span class="line">        fields = [<span class="string">&quot;name&quot;</span>, <span class="string">&quot;gender&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="string">&quot;create_time&quot;</span>, <span class="string">&quot;depart&quot;</span>, ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">for</span> name, obj <span class="keyword">in</span> self.fields.items():</span><br><span class="line">            obj.widget.attrs = &#123;<span class="string">&quot;class&quot;</span>: <span class="string">&quot;form-control&quot;</span>, <span class="string">&quot;placeholder&quot;</span>: <span class="string">&quot;请输入&quot;</span>+obj.label&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">user_update</span>(<span class="params">request, nid</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">        obj = models.UserInfo.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=nid).first()</span><br><span class="line">        form = UserModelForm(instance=obj)</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&#x27;user_update.html&#x27;</span>, &#123;<span class="string">&quot;form&quot;</span>: form, &#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        form = UserModelForm(data=request.POST, instance=models.UserInfo.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=nid).first())</span><br><span class="line">        <span class="keyword">if</span> form.is_valid():</span><br><span class="line">            form.save()</span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">&#x27;/user/list/&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> render(request, <span class="string">&#x27;user_update.html&#x27;</span>, &#123;<span class="string">&quot;form&quot;</span>: form, &#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="Django实现搜索功能"><a href="#Django实现搜索功能" class="headerlink" title="Django实现搜索功能"></a>Django实现搜索功能</h4><ul><li>利用字典进行搜索<br><img src="https://cdn.jsdelivr.net/gh/HuangLM03/BlogImg@main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-08-18%20230510.png"><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_dict = &#123;&#125;</span><br><span class="line">value = request.GET.get(<span class="string">&#x27;query&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> value:</span><br><span class="line">    data_dict[<span class="string">&quot;mobile__contains&quot;</span>] = value</span><br><span class="line">phone_number = models.PhoneNumber.objects.<span class="built_in">filter</span>(**data_dict).order_by(<span class="string">&#x27;level&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Django框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单源最短路</title>
      <link href="/2023/05/14/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
      <url>/2023/05/14/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h4 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h4><p>给定一个带权有向图G &#x3D;（V,E），其中每条边的权是一个实数。另外，还给定V中的一个顶点，称为源。要计算从源到其他所有各顶点的最短路径长度。这里的长度就是指路上各边权之和。这个问题通常称为单源最短路径问题。</p><h4 id="Dijkstra算法O-n-2"><a href="#Dijkstra算法O-n-2" class="headerlink" title="Dijkstra算法O(n^2)"></a>Dijkstra算法O(n^2)</h4><p>该算法是一种基于贪心的做法：从起点集合出发，每次寻找离起点所属集合最近的点，并标记该点已经属于起点集合，然后用该点的出边更新所有还不属于起点集合的点离起点集合的距离，直到所有的点都属于起点集合。</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dist数组是点离起点集合的距离，g[i][j]是两个点之间的距离</span></span><br><span class="line"><span class="built_in">Dijkstra</span>(<span class="type">int</span> beg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memest</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> );</span><br><span class="line">    dist[beg] = <span class="number">0</span>;<span class="comment">//起点到自己的距离为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="comment">//如果j不属于起点集合，并且t点离起点集合比j更远，就将t更新为j</span></span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j])) &#123;</span><br><span class="line">                t = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;<span class="comment">//标记t属于起点集合</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">          <span class="comment">//更新离起点的距离</span></span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Dijkstra算法堆优化（nlogn）"><a href="#Dijkstra算法堆优化（nlogn）" class="headerlink" title="Dijkstra算法堆优化（nlogn）"></a>Dijkstra算法堆优化（nlogn）</h4><p>很显然，上述算法固然正确，但是时间复杂度太高，一旦数据范围过大，很容易超时。因此，我们要对其进行优化。<br>优化方法：利用STL里面的priority_queue对找离起点集合最近的点这一步进行优化，这一步由O(n)优化为O(logn)。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapDijkstra</span><span class="params">(<span class="type">int</span> beg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[beg] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123; dist[beg], beg&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x = t.first, y = t.second;</span><br><span class="line">        <span class="keyword">if</span> (st[y]) <span class="keyword">continue</span>;</span><br><span class="line">        st[y] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//更新</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[y]; ~i; i = edge[i].nxt) &#123;</span><br><span class="line">            <span class="comment">//简化代码</span></span><br><span class="line">            <span class="type">int</span> j = edge[i].to;</span><br><span class="line">            <span class="comment">//如果更小就更新，同时将更新过的点入队列</span></span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[j] + edge[i].val) &#123;</span><br><span class="line">                dist[j] = dist[j] + edge[i].val;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123; dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中场总结"><a href="#中场总结" class="headerlink" title="中场总结"></a>中场总结</h4><p>Dijkstra算法的限制：不能出现负权边。<br>原因：该算法是基于贪心的做法，如果出现负权边则无法保证当前更新到的点是距离起点最小的点，如下图所示：<br><img src="https://s2.loli.net/2023/05/15/LMRAbesDWzdcZqV.png"><br>上述推导是很直观的推导，但是不严谨，更严谨的数学推导请自行google。</p><p>接下来我们将会介绍解决带负权边的最短路问题的算法：bellman-ford算法和SPFA算法，SPFA算法是bellman-ford算法的优化。因此，绝大部分能用bellman-ford算法解决的问题都可以用SPFA算法解决，且效率更佳，只有小部分问题，例如最多经过k条边的最短路问题无法用SPFA算法解决。</p><h4 id="bellman-ford算法O-nm"><a href="#bellman-ford算法O-nm" class="headerlink" title="bellman-ford算法O(nm)"></a>bellman-ford算法O(nm)</h4><p>该算法的主要思路是对所有边进行n - 1轮松弛操作，为在一个含有n个顶点的图中，任意两点之间的最短路径最多包含n-1边，除非该图有负权回路。换句话说，第1轮在对所有的边进行松弛后，得到的是起点最多经过一条边到达其他顶点的最短距离；第2轮在对所有的边进行松弛后，得到的是起点最多经过两条边到达其他顶点的最短距离；第3轮在对所有的边进行松弛后，得到的是起点最多经过三条边到达其他顶点的最短距离……那如果进行n - 1轮松弛操作后仍然可以进行松弛怎么办？答案是：此时我们可以判断出在这个图中有负权回路，部分点到起点的最短路无解。<br>也因为这个思路，这个算法可以解决最多经过k条边的最短路问题。<br><strong>特别注意</strong>，在记录最短路时，要用两个数组记录，<code>last[]</code>用来记录上一轮的最短路，<code>next[]</code>用来记录当前轮的最短路。更新的时候要用<code>last[]</code>来更新<code>next[]</code>，否则会出现一次更新两条边的情况，导致该算法无法求最多经过k条边的最短路问题（但是依旧可以求无边数限制的最短路问题）。下图举例一种简单的情况证明上述结论。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dist数组代表当前轮点离起点的距离，last数组代表上一轮点离起点的距离</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> from, to, val;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"><span class="type">void</span> bellman-ford(<span class="type">int</span> beg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化操作</span></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[beg] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="type">int</span> a = edge[i].from, b = edge[i].to, c = edge[i].val;</span><br><span class="line">            <span class="comment">//用上一轮的最短路更新这一轮的最短路，防止一次更新两条边。</span></span><br><span class="line">            dist[a] = <span class="built_in">min</span>(dist[a], last[b] + c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将上一轮的最短路赋值给last数组</span></span><br><span class="line">        <span class="built_in">memcpy</span>(last, dist, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SPFA算法一般O-m-，最坏O-nm"><a href="#SPFA算法一般O-m-，最坏O-nm" class="headerlink" title="SPFA算法一般O(m)，最坏O(nm)"></a>SPFA算法一般O(m)，最坏O(nm)</h4><p>SPFA算法是对bellman-ford算法优化得到的，但是有得必有失，优化后不能用于求最多经过k条边的最短路问题。从bellman-ford算法代码中可以看出，很多点的dist不会更新但却被遍历了。直觉告诉我们，这里有很大的优化空间。而SPFA算法正是这样做的：创建一个队列，将dist被更新的点入队，依次从队头取出元素，遍历该元素的所有出边（连向的点），看能否更新这些点的dist，若可以，则将其入队，否则跳过。<br>下面简要说明为什么可以跳过dist不会被更新的点。</p><ul><li>情况一：该点的dist已被更新过，即<code>dist[i] = last[j] + edge_val</code>。此时dist已是最小值，除非该点所在路径上出现负权回路。</li><li>情况二：last[j] &#x3D; INF。此时无论dist[i]更新与否，都不影响判定：i、j都不可达。</li></ul><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> st[N]; <span class="comment">//用于判断元素是否处于队列中</span></span><br><span class="line"><span class="type">int</span> h[N], idx;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to, val, nxt;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">(beg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[beg] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(beg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历出边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = edge[i].nxt) &#123;</span><br><span class="line">            <span class="type">int</span> j = edge[i].to;</span><br><span class="line">            <span class="comment">//判断是否更新t元素出边所连的点的dist</span></span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + edge[i].val) &#123;</span><br><span class="line">                dist[j] = dist[t] + edge[i].val;</span><br><span class="line">                <span class="comment">//重复入队只会增加时间损耗</span></span><br><span class="line">                <span class="keyword">if</span> (!st[j]) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Dijkstra算法一般用于正权图中，稠密图用朴素版，稀疏图用堆优化版；有负权边的图中一般用spfa算法，除非题目有边数限制才会用bellman-ford算法。</p>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
          <category> 单源最短路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 单源最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL常用容器</title>
      <link href="/2023/04/24/STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/"/>
      <url>/2023/04/24/STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>size和empty这两个函数所有的STL容器都支持<br>除了queue,priority_queue,stack之外，其他STL容器都有clear函数<br>begin和end一般都是左 [ 右 )</p><h4 id="vector（长度可变的数组）（变长基于倍增的思想）"><a href="#vector（长度可变的数组）（变长基于倍增的思想）" class="headerlink" title="vector（长度可变的数组）（变长基于倍增的思想）"></a>vector（长度可变的数组）（变长基于倍增的思想）</h4><p>声明方式：<br>       vector<int> a;&#x2F;&#x2F;定义了一个名字为a的vector数组<br>       同理，也可以<br>        struct _Node{int i;int j;}Node;<br>        vector<Node> a;<br>函数：<br>    a.size()&#x2F;&#x2F;表示vector的长度<br>    a.begin()&#x2F;&#x2F;；表示vector第一个元素的下标<br>    注意：<em>a.begin()与a[0]的作用相同（前提是a非空）<br>    a.end()&#x2F;&#x2F;表示vector最后一个元素的后一个位置的下标<br>    a.empty()&#x2F;&#x2F;表示a是否为空，返回值类型为bool，如空为true，不空为false<br>    a.clear()&#x2F;&#x2F;表示将a清空<br>    a.front()&#x2F;&#x2F;表示将a的第一个元素返回，相当于</em>a.begin()和a[0]<br>    a.back()&#x2F;&#x2F;表示将a的最后一个元素返回，同上<br>    a.earse(unique(a.begin(),a.end(),a.end())&#x2F;&#x2F;将位于两指针中间的元素删去<br>    (important)  a.pop_back()&#x2F;&#x2F;表示删去a的最后一个元素<br>               a.push_back(x)&#x2F;&#x2F;表示在a的最后一个元素后面加入一个新的元素x<br>                注意：vector在末尾插入数据的时间复杂度为O（1），但在vector头部插入数据的时间复杂度为O（n）<br>迭代器：<br>    迭代器就像STL容器的“指针”，可以用星号*操作符解除引用。<br>一个保存int的vector的迭代器声明方法为：vector<int>::iterator it;<br>    vector的迭代器是“随机访问迭代器”，可以把vector的迭代器与一个整数相加减，<br>其行为和指针的移动类似。可以把vector的两个迭代器相减，<br>其结果也和指针相减类似，得到两个迭代器对应下标之间的距离。</p><h4 id="queue（注意：只能从队尾插入，从队头弹出）"><a href="#queue（注意：只能从队尾插入，从队头弹出）" class="headerlink" title="queue（注意：只能从队尾插入，从队头弹出）"></a>queue（注意：只能从队尾插入，从队头弹出）</h4><p>声明方式：<br>    queue<int> q;<br>    struct rec{…}; queue<rec> q;                        &#x2F;&#x2F;结构体rec中必须定义小于号<br>    priority_queue<int> q;                              &#x2F;&#x2F; 大根堆，即每次返回最大值<br>    priority_queue&lt;int, vector<int>, greater<int>&gt; q;   &#x2F;&#x2F; 小根堆，即每次返回最小值<br>    priority_queue&lt;pair&lt;int, int&gt;&gt;q;<br>    注意：如果想定义一个结构体的优先队列，必须要重载小于号<br>        具体格式为：<br>        struct Rec{int a;int b;bool operator&lt; (const Rec&amp; t){ return a &lt; t.a;}};<br>        priority_quene<Rec> d;<br>        同理如果要定义一个小根堆则必须要重载大于号（将上述格式中的‘&lt;’换成’&gt;’即可）<br>函数：<br>    循环队列 queue<br>        push()&#x2F;&#x2F;从队尾插入<br>        pop()&#x2F;&#x2F;从队头弹出<br>        front()&#x2F;&#x2F;返回队头元素<br>        back()&#x2F;&#x2F;返回队尾元素<br>    优先队列 priority_queue<br>        psuh()&#x2F;&#x2F;插入一个数<br>        top()&#x2F;&#x2F;取出队列中的最大值<br>        pop()&#x2F;&#x2F;删除最大值</p><p>清空队列的方法：<br>    q&#x3D;queue<int>();</p><h4 id="stack-与queue类似，但数据先进先出"><a href="#stack-与queue类似，但数据先进先出" class="headerlink" title="stack(与queue类似，但数据先进先出)"></a>stack(与queue类似，但数据先进先出)</h4><p>声明方法：与queue类似</p><p>函数：<br>    push()&#x2F;&#x2F;向栈顶插入元素<br>    pop()&#x2F;&#x2F;弹出（删除）栈顶元素<br>    top()&#x2F;&#x2F;返回栈顶的元素</p><h4 id="deque-双端队列-vector和queue的组合：与vector相比，deque在头部增删元素仅需要-O-1-O-1-的时间；"><a href="#deque-双端队列-vector和queue的组合：与vector相比，deque在头部增删元素仅需要-O-1-O-1-的时间；" class="headerlink" title="deque 双端队列(vector和queue的组合：与vector相比，deque在头部增删元素仅需要 O(1)O(1) 的时间；"></a>deque 双端队列(vector和queue的组合：与vector相比，deque在头部增删元素仅需要 O(1)O(1) 的时间；</h4><pre><code>        与queue相比，deque像数组一样支持随机访问。）</code></pre><p>声明方法：与上面类似</p><p>函数：<br>    a.begin()  a.end()&#x2F;&#x2F;左闭右开，用法同vector<br>    a.front()  a.back()&#x2F;&#x2F;分别表示将队列的第一个元素和最后一个元素返回<br>    a.pop_back()  a.pop_front()&#x2F;&#x2F;分别表示将队列的第一个元素和最后一个元素删去<br>    a.clear()&#x2F;&#x2F;表示清空队列</p><h4 id="set-底层实现为红黑树"><a href="#set-底层实现为红黑树" class="headerlink" title="set (底层实现为红黑树)"></a>set (底层实现为红黑树)</h4><pre><code>头文件set主要包括set和multiset两个容器，分别是“有序集合”和“有序多重集合”，</code></pre><p>即前者的元素不能重复，而后者可以包含若干个相等的元素。<br>set和multiset的内部实现是一棵红黑树，它们支持的函数基本相同。<br>声明方法：<br>    set<int> a;&#x2F;&#x2F;元素不可以重复<br>    multiset<int> b;&#x2F;&#x2F;元素可以重复<br>    因为set内部需要进行比较，所以自己定义结构体时需要重载小于号<br>    具体方式：<br>        struct Rec{int x;int y;<br>                    bool operator&lt; (const Rec&amp; t)const<br>                    { return x &lt; t.x;}<br>                };<br>        set<Rec> c;</p><p>函数：<br>    size&#x2F;empty&#x2F;clear与vector类似<br>    begin()&#x2F;end()&#x2F;&#x2F;返回集合的首、尾迭代器，时间复杂度均为 O(1)<br>    &#x2F;&#x2F;s.begin()是指向集合中最小元素的迭代器。s.end()是指向集合中最大元素的下一个位置的迭代器。<br>    &#x2F;&#x2F;换言之，就像vector一样，是一个“前闭后开”的形式。因此– s.end()是指向集合中最大元素的迭代器。<br>&#96;insert()&#x2F;&#x2F;s.insert(x)把一个元素x插入到集合s中，时间复杂度为 O(logn)O(logn)。<br>    &#x2F;&#x2F;在set中，若元素已存在，则不会重复插入该元素，对集合的状态无影响。<br>    find()&#x2F;&#x2F;s.find(x)在集合s中查找等于x的元素，并返回指向该元素的迭代器。若不存在，则返回s.end()。时间复杂度为 O(logn)<br>    lower_bound()&#x2F;upper_bound()&#x2F;&#x2F;这两个函数的用法与find类似，但查找的条件略有不同，时间复杂度为 O(logn)。<br>    &#x2F;&#x2F;s.lower_bound(x)查找大于等于x的元素中最小的一个，并返回指向该元素的迭代器。<br>    &#x2F;&#x2F;s.upper_bound(x)查找大于x的元素中最小的一个，并返回指向该元素的迭代器。<br>    &#x2F;&#x2F;注意这两个函数，有坑！！！一个是大于等于，一个是大于（而不能想当然地认为一个是大于等于，一个是小于）<br>    &#x2F;&#x2F;erase()&#x2F;&#x2F;设it是一个迭代器，s.erase(it)从s中删除迭代器it指向的元素，时间复杂度为 O(logn)。<br>    &#x2F;&#x2F;设x是一个元素，s.erase(x)从s中删除所有等于x的元素，时间复杂度为 O(k+logn)，其中 kk 是被删除的元素个数。<br>    &#x2F;&#x2F;count()&#x2F;s.count(x)返回集合s中等于x的元素个数，时间复杂度为 O(k+logn)O(k+logn)，其中 kk 为元素x的个数。</p><p>迭代器：<br>    set和multiset的迭代器称为“双向访问迭代器”，<br>不支持“随机访问”，支持星号*解除引用，仅支持++和–两个与算术相关的操作。<br>设it是一个迭代器，例如set<int>::iterator it;<br>若把it ++，则it会指向“下一个”元素。<br>这里的“下一个”元素是指在元素从小到大排序的结果中，排在it下一名的元素。<br>同理，若把it –，则it将会指向排在“上一个”的元素。</p><h4 id="unordered-set-底层实现为哈希表"><a href="#unordered-set-底层实现为哈希表" class="headerlink" title="unordered_set(底层实现为哈希表)"></a>unordered_set(底层实现为哈希表)</h4><pre><code>所有的用法都和set相同，只比set少了lower_bound()和upper_bound()两个函数和迭代器的++，--</code></pre><p>（因为unordered_set是无序的）<br>    时间复杂相对set来说较低<br>同理也存在unordered_multiset</p><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>map容器是一个键值对key-value的映射，<br>其内部实现是一棵以key为关键码的红黑树。<br>Map的key和value可以是任意类型，其中key必须定义小于号运算符</p><h4 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h4><pre><code>时间复杂度都是O（1）的，与map相比（map的操作都是O（log n）），</code></pre><p>只少了二分和迭代器的++，–，但实际上一般不会用map做二分。<br>函数：<br>    size&#x2F;empty&#x2F;clear&#x2F;begin&#x2F;end均与set类似。<br>    insert&#x2F;erase与set类似，但其参数均是pair&lt;key_type, value_type&gt;。<br>    find&#x2F;&#x2F;h.find(x)在变量名为h的map中查找key为x的二元组。</p><p>不知道什么分类：<br>    []操作符&#x2F;&#x2F;h[key]返回key映射的value的引用，时间复杂度为 O(logn)。<br>    []操作符是map最吸引人的地方。我们可以很方便地通过h[key]来得到key对应的value，<br>还可以对h[key]进行赋值操作，改变key对应的value。</p><h4 id="pair-二元组"><a href="#pair-二元组" class="headerlink" title="pair 二元组"></a>pair 二元组</h4><p>声明方法：<br>    pair&lt;int,string&gt; a;<br>    a&#x3D;{3,”yxc”}<br>    a&#x3D;make_pair(4,”abc”);<br>输出方法：<br>    cout&lt;&lt;a.first&lt;&lt;’ ‘&lt;&lt;a.second&lt;&lt;endl;</p><h4 id="bitset-压位"><a href="#bitset-压位" class="headerlink" title="bitset 压位"></a>bitset 压位</h4><p>定义：<br>    bitset<length> a;</p><p>操作：<br>    ~,&amp;,|,^<br>    &gt;&gt;,&lt;&lt;<br>    &#x3D;&#x3D;,!&#x3D;<br>    []</p><p>函数：<br>    count &#x2F;&#x2F;返回有多少个1<br>    any() &#x2F;&#x2F;判断是否至少有一个1<br>    none() &#x2F;&#x2F;判断是否全为0<br>    set() &#x2F;&#x2F;把所有位置换为1<br>    set(k,v) &#x2F;&#x2F;把第k位变成v<br>    reset() &#x2F;&#x2F;把所有位变成0<br>    flip() &#x2F;&#x2F;等价于~<br>    flip（k） &#x2F;&#x2F;把第k位取反</p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><h4 id="常用库函数"><a href="#常用库函数" class="headerlink" title="常用库函数"></a>常用库函数</h4><p>使用下列函数要引头文件：#include <algorithm></p><h4 id="reverse（O（n））"><a href="#reverse（O（n））" class="headerlink" title="reverse（O（n））"></a>reverse（O（n））</h4><p>作用：将数组或vector翻转<br>写法：reverse(a.begin(),a.end())<br>    注意左 [ 右 ) </p><h4 id="unique-有返回值，返回值为新数组的end（）"><a href="#unique-有返回值，返回值为新数组的end（）" class="headerlink" title="unique 有返回值，返回值为新数组的end（）"></a>unique 有返回值，返回值为新数组的end（）</h4><p>作用：去重（前提：保证相同元素挨在一起），把所有不同的数据放在数组的最前面<br>写法：unique( a.begin(),a,end())</p><h4 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle"></a>random_shuffle</h4><p>作用：将数组打乱从而获得随机数组<br>写法：vector<int> a;<br>    srand(time(0))&#x2F;&#x2F;为了每次打乱得不同<br>    rand_shuffle(a.begin(),a.end())</p><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>作用：将数组排序<br>写法：vector<int> a;<br>    sort(a.begin(),a.end())&#x2F;&#x2F;默认从小到大排序<br>    sort(a.begin(),a.end(),greater<int>())&#x2F;&#x2F;从大到小排序<br>    &#x2F;&#x2F;自定义排序方法<br>    bool cmp(int a,int b){<br>        return a&gt;b;&#x2F;&#x2F;如果a&gt;b，那么a应该排到b的前面<br>    }&#x2F;&#x2F;a是否应该排到b的前面<br>    sort(a.begin(),a.end(),cmp)<br>    &#x2F;&#x2F;神奇的排结构体（和上面一样）<br>    &#x2F;&#x2F;如果不想每次都定义一个比较函数，可以在结构体内重载小于号（大于号）</p><h4 id="lower-bound-x2F-upper-bound-二分（要求已经排好序）"><a href="#lower-bound-x2F-upper-bound-二分（要求已经排好序）" class="headerlink" title="lower_bound&#x2F;upper_bound 二分（要求已经排好序）"></a>lower_bound&#x2F;upper_bound 二分（要求已经排好序）</h4><p>lower_bound的第三个参数传入一个元素x，<br>在两个迭代器（指针）指定的部分上执行二分查找，<br>返回指向第一个大于等于x的元素的位置的迭代器（指针）。<br>upper_bound的用法和lower_bound大致相同，<br>唯一的区别是查找第一个大于x的元素。当然，两个迭代器（指针）指定的部分应该是提前排好序的。</p><p>在有序int数组（元素存放在下标1 ~ n）中查找大于等于x的最小整数的下标：<br>int i &#x3D; lower_bound(a + 1, a + 1 + n, x) - a;<br>在有序vector<int>中查找小于等于x的最大整数（假设一定存在）：<br>int y &#x3D; *–upper_bound(a.begin(), a.end(), x);</p><p>如果无法找到则返回-1.</p>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2023/04/23/%E9%93%BE%E8%A1%A8/"/>
      <url>/2023/04/23/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近在面向对象程序设计一课中学习了有关链表的内容，因此写这篇博客巩固一下从类的角度写链表的方法。</p><h4 id="链表用途"><a href="#链表用途" class="headerlink" title="链表用途"></a>链表用途</h4><h4 id="链表原理简介"><a href="#链表原理简介" class="headerlink" title="链表原理简介"></a>链表原理简介</h4><ul><li>链表分为单向链表，双向链表还有循环链表等，这里以单链表为例介绍原理。</li></ul><ol><li>链表就是将一些孤立的类对象串联在一起，创建类对象不难，难点是如何将这些类对象串联起来。</li><li>回忆学习过的知识，我们学习过的索引方式只有两种：数组的下标索引和指针索引。很显然，数组的下标索引不如指针索引方便，因此，我这里利用指针进行索引；</li><li>我们先建立一个简单的类:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    string name, id;</span><br><span class="line">    <span class="type">int</span> classNum;</span><br><span class="line">    Student* next;<span class="comment">//要指向int类型的变量需要int*，与此类似，要指向Student对象需要Student*。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>具体如何操作看下图（图片比单调的文字描述更让人易懂）<br><img src="https://s2.loli.net/2023/04/24/f5vEJ6x7hLQCROB.jpg"></li><li>但是，我们的链表还有很多问题，例如：我如何找到这个链表在哪里？<br>答案很显然，在new第一个节点的时候我们多new一个head节点就可以了（如图<br><img src="https://s2.loli.net/2023/04/24/3r4GXBVyMJ9FRmq.jpg"></li><li>接下来是链表如何通过头节点进行插入和删除操作。<br>插入操作分为在head节点后面插入和末尾点插入还有中间插入，我们以最普遍的中间插入举例（如图<br><img src="https://s2.loli.net/2023/04/24/m2Hcb4i8GtejJAM.jpg"><br>然后是删除操作（依旧是如图<br><img src="https://s2.loli.net/2023/04/24/5r7tkpWFOKvIhE4.jpg"><br>简短的代码<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Student* p = i;</span><br><span class="line">Student* tmp = i-&gt;next;<span class="comment">//这一步是为了delete</span></span><br><span class="line">p-&gt;next = tmp-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br></pre></td></tr></table></figure></li><li>以上便是单链表的简单原理了，下面给出完整的代码</li></ol><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><p>更新：完善一下代码格式</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">StuClass</span>;</span><br><span class="line">    string name;</span><br><span class="line">    Student* next;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Student</span>(string na) : <span class="built_in">name</span>(na), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">        <span class="built_in">Student</span>() </span><br><span class="line">        &#123;</span><br><span class="line">            name = <span class="string">&quot;NO ONE&quot;</span>;</span><br><span class="line">            next = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StuClass</span> &#123;</span><br><span class="line">    Student* head;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">StuClass</span>(<span class="type">int</span> n) : <span class="built_in">sum</span>(n) </span><br><span class="line">        &#123;</span><br><span class="line">            head = <span class="keyword">new</span> Student;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">StuClass</span>();</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">record</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">lookThrough</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(Student*)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(string)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">StuClass::~<span class="built_in">StuClass</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Student* p = head-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> head;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        Student* tmp = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StuClass::record</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sum; i++) &#123;</span><br><span class="line">        string name;</span><br><span class="line">        cin &gt;&gt; name;</span><br><span class="line">        Student* now = <span class="keyword">new</span> <span class="built_in">Student</span>(name);</span><br><span class="line">        <span class="built_in">insert</span>(now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StuClass::lookThrough</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student* p = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;name &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StuClass::insert</span><span class="params">(Student* now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student* p = head-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        head-&gt;next = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StuClass::erase</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student* p = head-&gt;next;</span><br><span class="line">    Student* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;name != name) pre = p, p = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        head-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NOT FOUND! &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        pre-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">StuClass <span class="title">list</span><span class="params">(n)</span></span>;</span><br><span class="line">    list.<span class="built_in">record</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除前：&quot;</span>;</span><br><span class="line">    list.<span class="built_in">lookThrough</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    list.<span class="built_in">erase</span>(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除后：&quot;</span>;</span><br><span class="line">    list.<span class="built_in">lookThrough</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一些话"><a href="#一些话" class="headerlink" title="一些话"></a>一些话</h4><p>链表还有双向链表和循环链表等等，但原理和单链表几乎相同，有时间再更新。</p><h4 id="补充1"><a href="#补充1" class="headerlink" title="补充1"></a>补充1</h4><ul><li>在头节点后面插入与一般的插入有些许不同，我们需要更新一下head节点指向的位置，即：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Student* now = <span class="keyword">new</span> Student;</span><br><span class="line">now-&gt;next = head-&gt;next;</span><br><span class="line">head-&gt;next = now;</span><br></pre></td></tr></table></figure></li></ul><h4 id="补充2"><a href="#补充2" class="headerlink" title="补充2"></a>补充2</h4><ul><li>循环链表的实现方式：与普通链表类似，但判断是否到链表的末端不是用<code>p-&gt;next != nullptr</code>，而是修改为<code>p-&gt;next != head-&gt;next</code>；其次，我们在创建第一个节点的时候要让它指向自己（因为一个节点也是循环链表），即：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Node* head = <span class="literal">nullptr</span>;</span><br><span class="line">……</span><br><span class="line">Node* now = <span class="keyword">new</span> Node;</span><br><span class="line">now = &#123; value, <span class="literal">nullptr</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    haed = <span class="keyword">new</span> Node;</span><br><span class="line">    head-&gt;next = now;</span><br><span class="line">    now-&gt;next = now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="补充3"><a href="#补充3" class="headerlink" title="补充3"></a>补充3</h4><p>关于链表反转的代码，原理如图：<br><img src="https://s2.loli.net/2023/04/24/v2XabgmewPrQWAE.png"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//now表示当前节点，fa表示当前节点的父节点，返回值为链表最末尾的节点的地址</span></span><br><span class="line"><span class="function">Node* <span class="title">dfs</span><span class="params">(Node* now, Node* fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果当前节点为空，则上一个节点为最后一个节点，因此返回上一个节点的地址</span></span><br><span class="line">    <span class="keyword">if</span> (now == <span class="literal">nullptr</span>) <span class="keyword">return</span> fa;</span><br><span class="line">    </span><br><span class="line">    Node* tmp = <span class="built_in">dfs</span>(now-&gt;next, now);</span><br><span class="line">    <span class="comment">//反转，当前节点的下一个节点为当前节点的父节点</span></span><br><span class="line">    now-&gt;next = fa;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line"><span class="built_in">dfs</span>(head, <span class="literal">nullptr</span>);<span class="comment">//head节点的上一个节点为空</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure><h4 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h4>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可持久化数据结构（二）：可持久化权值线段树</title>
      <link href="/2023/03/24/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2023/03/24/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>这是可持久化数据结构的第二部分，介绍可持久化权值线段树（主席树）。这个数据结构的名字很多（好像没有比较统一的叫法，也是我孤陋寡闻），为了简洁，下面以主席树代替。</p><h4 id="主席树的用途"><a href="#主席树的用途" class="headerlink" title="主席树的用途"></a>主席树的用途</h4><ul><li>维护一段区间内的数的出现次数</li><li>在题目中一般用来求第K小（大）数</li></ul><h4 id="主席树和一般线段树的区别"><a href="#主席树和一般线段树的区别" class="headerlink" title="主席树和一般线段树的区别"></a>主席树和一般线段树的区别</h4><ol><li>主席树一般采用动态开点（应该是）建树，而一般线段树采用堆的方式建树。</li><li>主席树每个节点的l和r指向该节点的左右儿子，一般线段树每个节点的l和r表示该节点表示的区间的左右端点。</li></ol><h4 id="主席树的原理简单介绍（以求第k小为例）"><a href="#主席树的原理简单介绍（以求第k小为例）" class="headerlink" title="主席树的原理简单介绍（以求第k小为例）"></a>主席树的原理简单介绍（以<a href="https://www.acwing.com/activity/content/problem/content/1718/">求第k小</a>为例）</h4><p>每次插入一个数的时候，整棵树只有一条分支会被更新，其余部分保持不变。那么我们可以将上一个版本的树复制过来（与<a href="https://huanglm03.github.io/2023/03/19/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96trie/">可持久化trie</a>的指向操作类似, 不懂的可以点击链接前往查看关于指向操作的内容），复制完后再进行插入操作。这样，我们就得到了不同版本的树了。</p><h4 id="但是我们怎么通过不同版本的树求第K小的数呢？"><a href="#但是我们怎么通过不同版本的树求第K小的数呢？" class="headerlink" title="但是我们怎么通过不同版本的树求第K小的数呢？"></a>但是我们怎么通过不同版本的树求第K小的数呢？</h4><p>下文中的值域均指离散化后的值域。<br>不妨假设p &lt; q，在第p个版本到第q个版本之间，我们一定插入了q - p + 1个数，两颗树值域内的数的数量相减，结果也一定为q - p + 1（不要问为什么了，p版本插入的数量就是比q版本少啊，不要像我一样傻）。既然在整棵树的值域（假设为1<del>n），那么在区间 l</del>r（1 &lt;&#x3D; l &lt;&#x3D; r &lt;&#x3D; n)是否也有这样的性质呢？答案是肯定的。那么，查询的时候我们只需要像普通线段树那样查询就可以了。</p><h4 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定长度为 N 的整数序列 A，下标为 1∼N。现在要执行 M 次操作，其中第 i 次操作为给出三个整数 li,ri,ki，</span><br><span class="line">求 A[li],A[li+1],…,A[ri] (即 A 的下标区间 [li,ri])中第 ki 小的数是多少。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含两个整数 N 和 M。</span><br><span class="line">第二行包含 N 个整数，表示整数序列 A。</span><br><span class="line">接下来 M 行，每行包含三个整数 li,ri,ki，用以描述第 i 次操作。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">对于每次操作输出一个结果，表示在该次操作中，第 k 小的数的数值。</span><br><span class="line">每个结果占一行。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">N≤105,M≤104,|A[i]|≤109</span><br><span class="line">输入样例：</span><br><span class="line">7 3</span><br><span class="line">1 5 2 6 3 7 4</span><br><span class="line">2 5 3</span><br><span class="line">4 4 1</span><br><span class="line">1 7 3</span><br><span class="line">输出样例：</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> root[N], a[N],idx;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">&#125;tr[N &lt;&lt; <span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), x) - nums.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = ++idx;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    tr[p].l = <span class="built_in">build</span>(l, mid), tr[p].r = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> q = ++idx;</span><br><span class="line">    tr[q] = tr[p];</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tr[q].cnt++;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) tr[q].l = <span class="built_in">insert</span>(tr[p].l, l, mid, x);</span><br><span class="line">    <span class="keyword">else</span> tr[q].r = <span class="built_in">insert</span>(tr[p].r, mid + <span class="number">1</span>, r, x);</span><br><span class="line">    tr[q].cnt = tr[tr[q].l].cnt + tr[tr[q].r].cnt;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> q, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = tr[tr[q].l].cnt - tr[tr[p].l].cnt;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= cnt) <span class="keyword">return</span> <span class="built_in">query</span>(tr[q].l, tr[p].l, l, mid, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(tr[q].r, tr[p].r, mid + <span class="number">1</span>, r, k - cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        nums.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    nums.<span class="built_in">erase</span>(<span class="built_in">unique</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    root[<span class="number">0</span>] = <span class="built_in">build</span>(<span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i&lt;= n; i++) &#123;</span><br><span class="line">        root[i] = <span class="built_in">insert</span>(root[i - <span class="number">1</span>], <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="built_in">find</span>(a[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> l, r, x;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;</span><br><span class="line">        cout &lt;&lt; nums[<span class="built_in">query</span>(root[r], root[l - <span class="number">1</span>], <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, x)] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 可持久化数据结构 </category>
          
          <category> 主席树/权值线段树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主席树 </tag>
            
            <tag> 可持久化权值线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可持久化数据结构（一）：trie</title>
      <link href="/2023/03/19/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96trie/"/>
      <url>/2023/03/19/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96trie/</url>
      
        <content type="html"><![CDATA[<p>近日学习了可持久化数据结构,因此总结一下。那就从可持久化trie开始吧。  </p><h4 id="可持久化trie的用途"><a href="#可持久化trie的用途" class="headerlink" title="可持久化trie的用途"></a>可持久化trie的用途</h4><p>正常的trie树可以解决一些字符串问题和最大异或和问题，但是对于一些特殊的问题，例如有插入操作和询问区间最大异或和轮流出现的问题，正常的trie树就难以解决。这个时候就轮到可持久化trie树出场了。  </p><h4 id="可持久化trie的思路"><a href="#可持久化trie的思路" class="headerlink" title="可持久化trie的思路"></a>可持久化trie的思路</h4><ol><li>对于每次插入，我们可以构造一棵新的trie树（复制原有的trie树，再进行插入操作），这样我们就得到了不同版本的trie树。<strong>但是</strong>，每次插入操作我们都要遍历（复制）一整棵trie树，这样无论是时间复杂度还是空间复杂度都是极高的。</li><li>上述思路虽不可取，但有很大的启发性。我们思考能不能在上述思路的基础上进行优化呢？答案是完全可以！每次插入，我们只会在trie树中新增一条链，而其余部分保持不变。保持不变的这一部分我们可以在新树中指向它们，而不是全部复制过来，这样一来，我们构造新trie树的成本大大降低了（只需要新增一条链，外加几个指向原有trie树的操作）。这就是可持久化trie的思路<strong>（这段话看不懂没关系，理解下面的图就好了）</strong></li></ol><h4 id="正常的trie（左图）和可持久化trie（右图）的对比"><a href="#正常的trie（左图）和可持久化trie（右图）的对比" class="headerlink" title="正常的trie（左图）和可持久化trie（右图）的对比"></a>正常的trie（左图）和可持久化trie（右图）的对比</h4><p><img src="https://s2.loli.net/2023/03/19/LHinIsjvzkb68PO.jpg"></p><p>版本2的指向操作似乎并没有减少什么操作，但是版本3的指向操作（1次）帮我们节省了4次复制操作。以此类推，这棵树越复杂，节省的操作次数越多，时间复杂度和空间复杂度大大降低，从而变成可行的操作。<br><strong>重要的事情说三遍，指向操作是可持久化的核心操作！！！</strong><br><strong>重要的事情说三遍，指向操作是可持久化的核心操作！！！</strong><br><strong>重要的事情说三遍，指向操作是可持久化的核心操作！！！</strong>   </p><p>还有一个问题就是，我们如何知道一个点是哪一个版本的呢？其实很简单，我们开一个<code>maxId[N]</code>数组来记录就可以了。</p><h4 id="纸上谈兵没用，我们直接看题"><a href="#纸上谈兵没用，我们直接看题" class="headerlink" title="纸上谈兵没用，我们直接看题"></a>纸上谈兵没用，我们直接看题</h4><p>我们选取的是<a href="https://www.acwing.com/problem/content/258/">Acwing256最大异或和</a>。<br>#####题面</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个非负整数序列 a，初始长度为 N。有 M个操作，有以下两种操作类型：A x：添加操作，表示在序列末尾添加</span><br><span class="line">一个数 x，序列的长度 N 增大 1。Q l r x：询问操作，你需要找到一个位置 p，满足 l≤p≤r，使得：a[p] xor a[p+1]</span><br><span class="line"> xor … xor a[N] xor x最大，输出这个最大值。</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line">第一行包含两个整数 N，M，含义如问题描述所示。</span><br><span class="line">第二行包含 N 个非负整数，表示初始的序列 A。</span><br><span class="line">接下来 M行，每行描述一个操作，格式如题面所述。</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line">每个询问操作输出一个整数，表示询问的答案。</span><br><span class="line"></span><br><span class="line">每个答案占一行。</span><br><span class="line"></span><br><span class="line">数据范围</span><br><span class="line">N,M≤3×105,0≤a[i]≤107。</span><br><span class="line"></span><br><span class="line">输入样例：</span><br><span class="line">5 5</span><br><span class="line">2 6 4 3 6</span><br><span class="line">A 1 </span><br><span class="line">Q 3 5 4 </span><br><span class="line">A 4 </span><br><span class="line">Q 5 7 0 </span><br><span class="line">Q 3 6 6 </span><br><span class="line">输出样例：</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>可以按照上面的思路思考一下 <strong>（指向操作是重点）</strong>。  </p><p>ac代码附详细注释</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6e5</span> + <span class="number">10</span>, M = N * <span class="number">25</span>;</span><br><span class="line"><span class="type">int</span> tr[M][<span class="number">2</span>], root[N], s[N], maxId[M], idx;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> k, <span class="type">int</span> p, <span class="type">int</span> q)</span><span class="comment">//i代表当前版本号，k代表当前深度 = 树的深度 - k，</span></span></span><br><span class="line"><span class="function"><span class="comment">//p代表上个版本的trie树，q代表新版本的trie树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span>) &#123;<span class="comment">//已到达叶节点</span></span><br><span class="line">        maxId[q] = i;<span class="comment">//位于新增的链中，所以赋值当前版本号</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> v = s[i] &gt;&gt; k &amp; <span class="number">1</span>;<span class="comment">//不同于新增链的节点</span></span><br><span class="line">    <span class="keyword">if</span> (p) tr[q][v ^ <span class="number">1</span>] = tr[p][v ^ <span class="number">1</span>];<span class="comment">//指向操作!!!</span></span><br><span class="line">    tr[q][v] = ++idx;<span class="comment">//新增结点，与正常trie树新增节点相同</span></span><br><span class="line">    <span class="built_in">insert</span>(i, k - <span class="number">1</span>, tr[p][v], tr[q][v]);</span><br><span class="line">    maxId[q] = <span class="built_in">max</span>(maxId[tr[q][<span class="number">0</span>]], maxId[tr[q][<span class="number">1</span>]]);<span class="comment">//子节点可能存在以前版本的点（因为</span></span><br><span class="line">    <span class="comment">//加了指向操作）,所以要对两个子节点的版本取max才是该节点的版本</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> C, <span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">23</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> v = C &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (maxId[tr[p][v ^ <span class="number">1</span>]] &gt;= l) p = tr[p][v ^ <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> p = tr[p][v];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C ^ s[maxId[p]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);<span class="comment">//加快读写</span></span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    maxId[<span class="number">0</span>] = <span class="number">-1</span>;<span class="comment">//第0个版本没有任何节点，赋值-1是为了防止版本错误</span></span><br><span class="line">    root[<span class="number">0</span>] = ++idx;<span class="comment">//根节点是一个空的trie节点，因此是++idx</span></span><br><span class="line">    <span class="built_in">insert</span>(<span class="number">0</span>, <span class="number">23</span>, <span class="number">0</span>, root[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] ^ x;<span class="comment">//记录的是前缀异或和，每次s[i] ^ s[n] ^ 给定的x 相当于从</span></span><br><span class="line">        <span class="comment">// i + 1 个数一直异或到最后一个数 (l &lt;= i &lt;= r)</span></span><br><span class="line">        root[i] = ++idx;</span><br><span class="line">        <span class="built_in">insert</span>(i, <span class="number">23</span>, root[i - <span class="number">1</span>], root[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        <span class="type">int</span> l, r, x;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            n++;</span><br><span class="line">            s[n] = s[n - <span class="number">1</span>] ^ x;</span><br><span class="line">            root[n] = ++idx;</span><br><span class="line">            <span class="built_in">insert</span>(n, <span class="number">23</span>, root[n - <span class="number">1</span>], root[n]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">query</span>(root[r - <span class="number">1</span>], s[n] ^ x, l - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="至此，完结撒花！！！"><a href="#至此，完结撒花！！！" class="headerlink" title="至此，完结撒花！！！"></a>至此，完结撒花！！！</h4>]]></content>
      
      
      <categories>
          
          <category> 可持久化数据结构 </category>
          
          <category> 可持久化trie </category>
          
      </categories>
      
      
        <tags>
            
            <tag> trie </tag>
            
            <tag> 可持久化数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>演示文稿</title>
      <link href="/2023/03/07/%E6%BC%94%E7%A4%BA%E6%96%87%E7%A8%BF/"/>
      <url>/2023/03/07/%E6%BC%94%E7%A4%BA%E6%96%87%E7%A8%BF/</url>
      
        <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Welcome to my blog!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 文章效果展示 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 演示 </tag>
            
            <tag> 展示 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
